\begin{section}{FHE, SFHE et bootstrapping}


Nous indiquons ici les définitions de base d'un FHE tirées de 
l'exposition faite dans~\cite{halevi} et que nous conseillons 
de lire pour avoir plus de détails.

\begin{definition}
Un cryptosystème homomorphe est constitué de $4$ fonctions:
\[ \text{\textbf{HE}} = (\Keygen, \Enc, \Dec, \Eval)\]
où $M$ est  l'espace des clairs, et un espace $C$ de chiffré. Plus précisément:
\begin{itemize}
\item $(\pk,, \sk) \leftarrow \Keygen(1^\kappa)$, $\kappa$ étant le paramètre de sécurité, retourne une clé publique, une clé d'évaluation et une clé secrète.
\item $c \leftarrow \Enc_{\pk}(\mu)$ prend une clé publique $\pk$, un clair $\mu \in R$ et retourne un chiffré $c\in C$
\item $\mu \leftarrow \Dec_{\sk}(c)$ prend une clé secrete $\sk$, un chiffré $c \in C$ et retourne un clair $\mu \in M$.
\item $\vec{c}_f \leftarrow \Eval_\pk(\Pi,\vec{c})$ prend une clé publique
$\pk$, un circuit  $\Pi$, un vecteur de chiffrés $\vec{c}$ et retourne un
vecteur de chiffrés $c_f$, un pour chaque sortie du circuit $\Pi$
\end{itemize}
\end{definition}

\begin{definition}{correction}
Soit \textbf{E} = $(\Keygen, \Enc, \Dec, \Eval)$ un cryptosystème homomorphique
et  $\mathcal{C} = \{ \mathcal{C}_\tau\}_{\tau \in \mathbb{N}}$ une famille de
circuits.  On dira que \textbf{E} est correct pour $\mathcal{C}$
Si il déchiffre avec succès les messages qui viennent d'être chiffrés 
ainsi que ceux qui ont été évalués sur un circuit. Voir \cite{halevi} pour les
formules détaillées.
\end{definition}

\begin{definition}{Compacité}
Un cryptosystème homomorphe \textbf{E} = $(\Keygen, \Enc, \Dec, \Eval)$ 
est compact si il existe un polynome $B$ tel que pour tout $\lambda, \tau
\in \mathbb{N}$, tout circuit $\Pi$ de $t$ entrées et une seule sortie, et un
chiffré $b = (b_1,\cdots,b_t) \in M^t$, on a:
\[ 
\PP \left[ |c'| \leq B(\lambda): (\sk,\pk) \leftarrow \Keygen(1^\lambda,
1^\tau), \vec{c} \leftarrow \Enc_\pk(\vec{b}), \vec{c} \leftarrow 
\Eval_\pk(\Pi, \vec{c}) \right] = 1
\]
\end{definition}

\begin{definition}{FHE, LHE et SWHE}
Soit \textbf{E} un cryptosystem homomorphe.
\begin{itemize}
\item On dit que c'est un fully homomorphic encryption (abrégé en FHE) si il est correct pour
une famille $\mathcal{C}$ telle que $\mathcal{C_1}$ contient déjà tous les
circuits booléens. 
\item On dit que c'est un  leveled homomorphic encryption (abrégé en LHE)  si il est correct pour une famille
$\mathcal{C}$ telle que pour tout $\tau$, $\mathcal{C}_\tau$ contient les
circuits booléens de profondeur plus petite ou égale à $\tau$ 
\item On dit, informellement, qu'il s'agit d'un somewhat homomorphic encryption
(abrégé en SWHE) si il est correct pour une famille $\mathcal{C}$ de circuits
tels que la complexité des circuits de $\mathcal{C}_\tau$ grandis avec $\tau$.
\end{itemize}
\end{definition}

Nous allons maintenant définir le bootstrapping en introduisant pour cela
quelques notations.

\begin{itemize}
\item Pour $\lambda, \tau \in \mathbb{N}$, on désigne par
$\mathcal{CT}_\epsilon(\lambda,\tau)$ comme l'union des chiffrés de messages 
ainsi que des évaluations de chiffrés de messages par des circuits de
$\mathcal{C}_\tau$, les formules détaillées sont donnés dans \cite{halevi};
\item On considère pour tout chiffré $c\in\mathcal{CT}_\epsilon(\lambda,\tau)$ 
le circuit $D_c(\sk) = \Dec_\sk(c)$ ayant pour entrée $\sk$ appliquant 
l'algorithme de déchiffrement de $c$ avec la clé $\sk$. Notons bien que $c$
n'est pas une entrée du circuit. On crée aussi le circuit suivant, avec pour
unique entrée \sk, appelé circuit de déchiffrement augmenté de $c_1$ et $c_2$
\[ D*_{c_1,c_2}(sk) := \text{NAND}(D_{c_1}(\sk), D_{c_2}(\sk))\]
\end{itemize}

\begin{definition}{Bootstrappable encryption}
Un cryptosystème homomorphe
\textbf{E} = $(\Keygen, \Enc, \Dec, \Eval)$
est bootstrappable si il peut évaluer homomorphiquement tous les circuits 
de chiffrement augmentés. Autrement dit, si il existe une fonction $\tau$
bornée par un polynôme tel que pour tous $\lambda \in \mathbb{N}$ et tous
chiffrés  $c_1, c_2 \in \mathcal{CT}_\epsilon{\lambda, \tau(\lambda)}$, on a
$D*_{c_1,c_2} \in \mathcal{C}_{\tau(\lambda)}$.
\end{definition}

\begin{definition}{weak circular security}
Soit \textbf{E} = $(\Keygen, \Enc, \Dec)$ un cryptosystème et $\mathcal{A}$ un
algorithme polynomial probabiliste. 
On considère l'expérience suivante, 
\begin{itemize}
\item $1^\tau \leftarrow \mathcal{A}(1^\lambda)$ 
\item $(\sk, \pk) \leftarrow \Keygen(1^\lambda, 1^\tau)$
\item on chiffre chaque bit de la clé secrète et on obtient un vecteur de
chiffrés $\vec{c^*} \leftarrow \Enc_\pk{s_k}$
\item un bit $b\in \{0,1\}$ est tiré au hasard
\item On crée $c \leftarrow \Enc_\pk(b)$ 
\item $b^* \leftarrow \mathcal{A}(\pk, \vec{c^*}, c)$
\item L'expérience est réussie si $b = b^*$ et ratée sinon.
\end{itemize}
Notant $p(\lambda, \mathcal{A})$ la probabilité de succès de cette expérience, on dit
que $\mathcal{A}$ a un avantage de sécurité circulaire sur \textbf{E} si:
\[\lambda \mapsto |p(\lambda, \mathcal{A}) - \frac{1}{2}| \]
est négligeable.
\end{definition}

\begin{thm}
Tout cryptosysteme homomorphe bootstrappable avec sécurité circulaire peut être transformé en un 
cryptosystème fully homomorphe compact.
\end{thm}

% \begin{definition}{Cryptosystème $\mathcal{C}$-homomorphe}
% On considère une famille d'ensembles fonctions $\mathcal{C} = \{\mathcal{C}_{k} \}_{k\in \mathbb{N}}$. \textbf{HE} est dit 
% $\mathcal{C}$-homomorphe  si pour toute fonction $f_k \in \mathcal{C}_k$, et
% pour toutes entrées $\mu_1, \cdots \mu_l \in R$ de la fonction $f_k$:
% \[ \PP\left(\Dec_\sk\left(\Eval_\evk(f,c_1,\cdots,c_l)\right) \neq f(\mu_1,\cdots,\mu_l)  \right) \]
% est négligeable en $k$, pour $(\pk, \evk, \sk) \leftarrow \Keygen(1^\kappa)$ et $c_i \leftarrow \Enc_\pk(\mu_i)$.
% \end{definition}



% \begin{definition}
% Soit $(M, +, x, 0, 1)$ un anneau. On appelle circuit algébrique 
% l'ensemble $\mathcal{A}_M$ de fonctions stable par composition et
% contenant:
% \begin{itemize}
% \item la fonction somme $\text{\textbf{Add}}: M \times M \rightarrow M$;
% \item la fonction produit $\text{\textbf{Mul}}: M \times M \rightarrow M$;
% \item Pour tout $\alpha \in M$, la fonction de multiplication par un scalaire
% $\text{\textbf{Scal}}_\alpha: M \rightarrow M$;
% \end{itemize}
% La profondeur d'un circuit algébrique est la profondeur obtenue
% en décomposant le circuit sous la forme d'un arbre.
% \end{definition}

% % \begin{definition}{Cryptosystème pleinement homomorphe (FHE)}
% % Un cryptosystème est pleinement homomorphe si son ensemble de clairs $M$ est
% % muni d'une structure d'anneau et si il est $\mathcal{A}_M$-homomorphe.
% % \end{definition}
% % \begin{definition}{Cryptosystème pleinement homomorphe (FHE)}
% % Un cryptosystème est homomorphe pour la profondeur $h = h(\kappa)$$ si son ensemble de clairs $M$ est
% % muni d'une structure d'anneau et si il est $\mathcal{C}=\{\mathcal{C}_k\}$-homomorphe.
% % où $\mathcal{C}_k$ sont les circuits algébriques de profondeur au plus $h(k)$.
% % Notons que si on applique homomorphiquement un circuit de profondeur $p < h(k)$
% % à $c = \Enc_{\pk}(\mu)$, on peut donc encore lui appliquer un circuit de
% % profondeur $h(k) - p$.
% % \end{definition}

% \begin{definition}{leveled fully homomorphic encryption}
% Un leveled fully homomorphic encryption est un cryptosystème homomorphe pour 
% lequel $\Keygen$ contient une entrée supplémentaire $1^L$, et le schéma
% résultant est homomorphe pour les circuits algébriques de profondeur $L$.
% $\text{\textbf{HE}} = (\Keygen, \Enc, \Dec, \Eval)$
% \end{definition}

% \begin{subsection}{SFHE et bootstrapping}

% \begin{definition}{leveled fully homomorphic encryption}
% Un somewhat fully homomorphic encryption est un cryptosystème homomorphe
% pour une classe $\mathcal{C}$ de fonctions tel que $\mathcal{C}_k$
% contient $\text{\textbf{Add}} \circ \Dec_\sk$  $\text{\textbf{Mult}} \circ \Dec_\sk$ 
% $\text{\textbf{Scal}}_\alpha \circ \Dec_\sk$ et peut encore effectuer 

% lequel $\Keygen$ contient une entrée supplémentaire $1^L$, et le schéma

% $\text{\textbf{HE}} = (\Keygen, \Enc, \Dec, \Eval)$
% \end{definition}

% La plupart des FHE sont construits à partir de ce que l'on appelle un Somewhat Fully-Homomorphic Encryption (SFHE).
% Il s'agit d'un cryptosystème homomorphe pour les circuits algébriques 
% d'une certaine profondeur $h$ auquel on rajoute certaines propriété.

% L'idée est qu'appliquer homomorphiquement \textbf{Add}, \textbf{Mul} ou
% \textbf{Scal} sur des chiffrées crée un \og bruit \fg, qui lorsqu'il est trop
% grand, empêche un déchiffrement correct et limite donc la profondeur des
% circuits algébriques utilisables.

% On demande toutefois deux conditions supplémentaires:
% \begin{itemize}
% \item $\Dec_\sk$ peut s'exprimer comme un circuit algébrique appartenant à  $\mathcal{C}$;
% \item le bruit crée par ce circuit est 
% \end{itemize}


% \begin{definition}{Cryptosystème avec amorçage (bootstrappable)}
% $\text{\textbf{HE}} = (\Keygen, \Enc, \Dec, \Eval)$

% \end{definition}



\end{section}
