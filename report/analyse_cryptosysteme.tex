\begin{section}{Analyse du cryptosystème: sécurité, profondeur des circuits}
	\begin{subsection}{Sécurité du cryptosystème}

	\begin{definition}{Distance statistique}
	Soit $X$ et $Y$ deux variables aléatoires supportée par
	un ensemble $\mathcal{V}$ et à valeur 
	dans un groupe abélien $G$. On définit la distance 
	statistique entre $X$ et $Y$, notée $\SD(X,Y)$, 
	comme étant la somme:
	\[ \frac{1}{2} \sum_{v \in \mathcal{V}} |\mathbb{P}(X = v) -
	\mathbb{P}(Y = v)| \]

	% \begin{prop}
	% Pour $X$ et $Y$ définies comme précédemment, on a:
	% \[\SD(X,Y) = \max_{\mathcal{W}\subset\mathcal{V}} | \PP(X\in\mathcal{W}) - \PP(Y\in\mathcal{W})| \]
	% \end{prop}
	% \begin{proof}
	% \end{proof}

	\end{definition}
	\begin{lemme}
	Soit $G$ un groupe abélien fini. Pour $r > 1$ et 
	$\mathcal{F} \subset (g_1, \ldots, g_r) \in G^r$, on
	note
	 $s_\mathcal{F}$ la distribution aléatoire qui à un aléa
	 fait correspondre la somme $\sum_{i\in X} g_i$ pour un
	 sous-ensemble choisi de façon uniforme  $X\subset \llbracket
	 1, r \rrbracket$. 
	 Considérons alors le n-uplet $S_\mathcal{F} = (X_1, \ldots, X_r)$ où 
	 les $X_i$ sont indépendants de même loi
	 $s_\mathcal{F}$.
	 D'autre part, on considère la distribution uniforme
	 $U$ sur $G^r$
	 Alors, on a: 
	 \[\mathbb{E}_{\mathcal{F}\subset G^r}(SD(s_\mathcal{F},U)) \leq 
	   \sqrt{r^2\frac{|G|}{2^r}}\]
	 Notamment, 
	 \[\mathbb{P}\left(SD(s_\mathcal{F},U) \geq
		 \sqrt[\leftroot{-3}\uproot{8}4\:]{r^2\frac{|G|}{2^r}} \right) \leq
		 \sqrt[\leftroot{-3}\uproot{8}4\:]{r^2\frac{|G|}{2^r}}
	 \]
	\end{lemme}
	\begin{proof}
	\end{proof}
	\begin{prop}
	Supposons avoir pris des paramètres $(n, q, \chi, m)$
	tels que l'hypothèse $\LWE$ soit vraie. Alors pour $\epsilon>0$
	et $m > (1+\epsilon)(n+1)\log(q)$ et $m = \mathcal{O}(n\log(q))$ , la distribution jointe 
	$(A, RA)$ est calculatoirement indistinguable de la
	distribution uniforme sur $\ZZq^{m \times (n+1)} \times \ZZq^{N
	\times (n+1)}$
	\end{prop}
	\begin{proof}
	On peut deja voir que comme $A$ est calculatoirement
	indistinguable de $U$, $(A, RA)$ l'est de $(U,RU)$ car on 
	peut facilement créer $(A, RA)$ (resp. $(U, RU)$) à partir de
	$A$ (resp. $U$).

	Il nous faut donc monter que $\mathcal{D}_1 = (U, RU)$ est calculatoirement
	indistinguable de $\mathcal{D}_2 = (U, V)$ où $V$ est uniforme.
	
	On peut alors utiliser le lemme précédent avec $G = \ZZq^{n+1}$
	et $r = m$ afin de voir qu'il echiste une constante $\lambda > 0$
	telle que:
	\[\mathbb{E}_{\mathcal{U}\subset \ZZq^{m\times n+1}}(SD(RU,V)) \leq 
		\sqrt{m^2\frac{q^{n+1}}{2^m}}\leq \lambda
	n\log(q)\sqrt{\frac{1}{q^{\epsilon(n+1)}}}=: f(n) \]
	Et, notant $Y = \{ U: \SD(RU,V) \geq \sqrt{f(n)}\}$, on obtient:
	\[\PP(U \in Y) \leq \sqrt{f(n)} \]
	où $f$ est négligeable en $n$. 



	
	Soit $(x,y)\in \ZZq^{m \times (n+1)} \times \ZZq^{m \times (n+1)}$
	\begin{align*}
	&\left|\PP(D_1 = (x,y)) - \PP(D_2 = (x,y))\right| \\ &\leq \PP(x\in Y)\:
	\Big|\PP(D_1 
	= (x,y)| x\in Y) - \PP(D_2 = (x,y)|x\in Y)\Big| + \PP(x \not\in Y)  \\
	&\leq |\PP(D_1 = (x,y) | x \in Y) - \PP(D_2 = (x,y)|x \in Y)| + \sqrt{f(n)} \\
	&\leq 2\sqrt{f(n)} 
	\end{align*}
	
	Ainsi, il n'est pas possible qu'un automate $\mathcal{A}$
	polynomial probabiliste puisse distinguer 
	$\mathcal{D}_1$ de $\mathcal{D}_2$ car il devrait distinguer
	des valeurs exponentiellement proches. (A PRECISER)
	\end{proof}

	\begin{thm}
	Sous les hypothèses de la proposition précédente, le
	cryptosysteme est IND-CPA.
	\end{thm}
	\begin{proof}
	Comme un automate polynomial probabiliste ne peut pas distinguer
	$A_{s, \chi}$ de la distribution uniforme, on peut supposer que la
	clef publique $A$ est uniforme.

	Considérons alors un chiffré 
	\[C = \flatten\left(\mu \cdot \id_N + \bitdecomp(R\cdot A)\right) \in
	\ZZq^{N\times N}\]

	On a:
	\[ \bitdecomp^{-1}(C) = \mu * \bitdecomp(\id_N) + R\cdot A\]

	Par la proposition précédente, un automate polynomial probabiliste $\mathcal{A}$
	ne peut pas distinguer $R\cdot A$ d'une matrice uniforme. On peut donc
	supposer que $R\cdot A$ est uniforme, et que le chiffrement est donc
	un one-time pad.

	On en déduit qu'il n'existe pas d'automate polynomial probabiliste
	$\mathcal{A}$ permettant de déchiffrer efficacement les chiffrés de ce cryptosystème.
	\end{proof}
	
	\end{subsection}
	\begin{subsection}{Choix de paramètres, deux visions}
	Le choix des paramètres du système est une étape cruciale de la mise en place de celui-ci,
	car ce sont eux qui détermineront les degrés de sécurités et la profondeur des circuits calculables.
	Pour savoir quels paramètres choisir, il existe deux méthodes :
	
	Tout d'abord, l'on peut et l'on doit étudier le sujet sur le plan théorique afin de déterminer
	l'ordre de grandeur des paramètres.
	
	Cependant, cette analyse asymptotique est insuffisante pour les cas concrets. Pour palier à ce
	problème, l'on peut étudier un certain choix précis de paramètres en essayant de l'attaquer afin
	d'estimer sa résistance concrète aux attaques.
	
	\begin{subsubsection}{Quelques choix de paramètres}

	le module \path{sage.crypto.lwe} contient des choix de paramètres pour
	le problème LWE, dont deux qui utilisent la gaussienne discrète
	\footnote{un autre utilise la distribution uniforme}
	et que nous allons présenter ici. Notons que nous avons pour cela 
	regardé les codes 
	sources des fonctions sage, disponibles dans leur github (\cite{sage}).

	\paragraph{}
	\textbf{Les paramètres de Regev}
	\paragraph{}

	La fonction Regev permet, à partir d'un paramètre $n$, de 
	créer des paramètres $n, q, \chi$ suivant les recommandations  
	faites dans \cite{STOC:Regev05} où le théorème~1.1 explique 
	qu'alors, $\LWE$ se réduit à un problème de réseaux réputé 
	difficile.

	Plus précisément, pour $n$ donné, il retourne
	\[q = \text{NextPrime}(n^2), \chi = D^q_\alpha\quad\text{où}\quad \alpha \frac{1}{q\sqrt{n} \log(n)^2}\]

	\begin{lstlisting}
	q = ZZ(next_prime(n**2))
	s = RR(1/(RR(n).sqrt() * log(n, 2)**2) * q)
	D = DiscreteGaussianDistributionIntegerSampler(s/sqrt(2*pi.n()), q)
	\end{lstlisting}

	\paragraph{}
	\textbf{Les parametres de Lindner et Peiker}
	\paragraph{}
	Il sont définis dans  \cite{EPRINT:LinPei10a} et on peut voir dans 
	le listing suivant la façon dont sage crée ces paramètres.
	\begin{lstlisting}{}
	- ``n`` - security parameter (integer > 0)
	- ``delta`` - error probability per symbol (default: 0.01)
	- ``m`` - number of allowed samples or ``None`` in which case ``m=2*n +
	  128`` as in [LP2011]_ (default: ``None``)
	"""
	if m is None:
	    m = 2*n + 128
	# Find c>=1 such that c*exp((1-c**2)/2))**(2*n) == 2**-40
	#         (c*exp((1-c**2)/2))**(2*n) == 2**-40
	#    log((c*exp((1-c**2)/2))**(2*n)) == -40*log(2)
	#       (2*n)*log(c*exp((1-c**2)/2)) == -40*log(2)
	#  2*n*(log(c)+log(exp((1-c**2)/2))) == -40*log(2)
	#            2*n*(log(c)+(1-c**2)/2) == -40*log(2)
	#              2*n*log(c)+n*(1-c**2) == -40*log(2)
	#  2*n*log(c)+n*(1-c**2) + 40*log(2) == 0
	c = SR.var('c')
	c = find_root(2*n*log(c)+n*(1-c**2) + 40*log(2) == 0, 1, 10)
	# Upper bound on s**2/t
	s_t_bound = (sqrt(2) * pi / c / sqrt(2*n*log(2/delta))).n()
	# Interpretation of "choose q just large enough to allow 
	# for a Gaussian parameter s>=8" in [LP2011]_
	q = next_prime(floor(2**round(log(256 / s_t_bound, 2))))
	# Gaussian parameter as defined in [LP2011]_
	s = sqrt(s_t_bound*floor(q/4))
	# Transform s into stddev
	stddev = s/sqrt(2*pi.n())
	D   = DiscreteGaussianDistributionIntegerSampler(stddev)
	LWE.__init__(self, n=n, q=q, D=D, secret_dist='noise', m=m)
	\end{lstlisting}

	\end{subsubsection}

	\begin{subsubsection}{lwe\_estimator : une estimation "concrète"}
	
		Initialement utilisé dans l'article
		\cite{EPRINT:AlbPlaSco15},\path{lwe_estimator}
		(disponible à l'adresse \cite{estimator}) est un module de sagemath actuellement maintenu par
	Martin Albrecht et 
	destiné à estimer la résistance face à diverses attaques de paramètres précis pour
	le problème de learning with error.
	
	
	\paragraph{}
	\textbf{estimate\_lwe :}

	\paragraph{}
	Cependant, l'intérêt premier de ce module est qu'il estime la résistance des paramètres choisis à
	plusieurs attaques. Pour cela, on utilise la fonction \path{estimate_lwe} :
	
	\flushleft
	
	\begin{lstlisting}
estimate_lwe(n, alpha=None, q=None, secret_distribution=True, m=oo,
             reduction_cost_model=reduction_default_cost,
             skip=("mitm", "arora-gb", "bkw"))
        \end{lstlisting}
	
	\flushleft
	
	Cette dernière prends en arguments les paramètres usuels de LWE, n, $\alpha$ et q, ainsi que
	d'autres arguments optionnels et rend plusieurs résultats dont le sens n'est pas forcément évident.
	En fait, elle retourne tout un ensemble de variables pour chaque attaque vérifiée. Le module
	contient 6 attaques différentes, mais n'en testera que trois par defaut. Cela peut être modifié
	lorsque l'on appelle la fonction \path{estimate_lwe} via l'argument skip.
	
	\flushleft
	
	\begin{lstlisting}[mathescape=true]
sage: n, alpha, q = Param.Regev(128)
sage: costs = estimate_lwe(n, alpha, q)
usvp: rop: 2^57.7, red: 2^57.7, $\delta$_0: 1.009214, $\beta$: 102, d: 357, m: 228
 dec: rop: 2^61.5, m: 229, red: 2^61.5, $\delta$_0: 1.009595, $\beta$: 93, d: 357,
     babai: 2^46.8, babai_op: 2^61.9, repeat: 293, $\epsilon$: 0.015625
dual: rop: 2^81.4, m: 376, red: 2^81.4, $\delta$_0: 1.008810, $\beta$: 111, d: 376,
     |v|: 736.521, repeat: 2^19.0, $\epsilon$: 0.003906
	\end{lstlisting}

	\flushleft
	
	Les variables rendues pour chaque attaques ne sont pas toutes utiles, certaines étant strictement
	internes à ces attaques. Les trois variables qui nous interresse sont : "rop", "m" et "mem" :
	
	\begin{itemize}
	\item "rop" (ring operations) est une estimation du nombre d'opérations à effectuer afin de résoudre
	ce cas de LWE avec cette attaque.
	
	\item "mem" (memory) est une estimation de la mémoire qui sera exploitée.
	
	\item "m" indique le nombre d'échantillons nécessaires pour résoudre le problème avec ces valeurs de
	"rop" et "mem". A noter que l'on peut limiter le nombre d'échantillons disponibles pour l'attaquant
	lorsqu'on appelle \path{estimate_lwe}.
	\end{itemize}

	\end{subsubsection}
	\end{subsection}
	\begin{subsection}{Analyse asymptotique de la profondeur des circuits}
		% la preuve de sécurité
	\end{subsection}
	\begin{subsection}{Mise en place du Bootstrapping avec DEC}
	\end{subsection}
\end{section}
