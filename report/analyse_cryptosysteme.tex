\begin{section}{Analyse du cryptosystème: sécurité, profondeur des circuits}
	\begin{subsection}{Sécurité du cryptosystème}

	\begin{definition}{Distance statistique}
	Soit $X$ et $Y$ deux variables aléatoires supportée par
	un ensemble $\mathcal{V}$ et à valeur 
	dans un groupe abélien $G$. On définit la distance 
	statistique entre $X$ et $Y$, notée $\SD(X,Y)$, 
	comme étant la somme:
	\[ \frac{1}{2} \sum_{v \in \mathcal{V}} |\mathbb{P}(X = v) -
	\mathbb{P}(Y = v)| \]

	De plus, on dira que deux familles ${\{X_i\}}_{i \in \NN}$, ${\{Y_i\}}_{i \in \NN}$
	de distributions sont statistiquement indistinguables si 
	la fonction 
	\[ i \longrightarrow \SD(X_i, Y_i) \]
	est négligeable.

	% \begin{prop}
	% Pour $X$ et $Y$ définies comme précédemment, on a:
	% \[\SD(X,Y) = \max_{\mathcal{W}\subset\mathcal{V}} | \PP(X\in\mathcal{W}) - \PP(Y\in\mathcal{W})| \]
	% \end{prop}
	% \begin{proof}
	% \end{proof}


	\end{definition}
	\begin{prop} \label{sd_add}
	Soit ${(X_i)}_{1\leq i \leq n}$ et resp .${(Y_i)}_{1\leq i\leq n}$
	deux n-uplets de distributions indépendantes.
	\[ \SD\left((X_1,\cdots,X_n), (Y_1, \cdots, Y_n)\right) \leq \sum_{i=1}^n \SD(X_i,Y_i) \]
	\end{prop}




	\begin{proof}
	Montrons le pour $n = 2$, la suite se déduisant par récurrence.
	On a:
	\begin{align*}
		&\SD\left((X_1,X_2),(Y_1,Y_2)\right) \\
		&= \frac{1}{2} \sum_{(u,v)}\left| \PP(X_1=u)\PP(X_2=v) -
		\PP(Y_1=u)\PP(Y_2=v) \right| \\ 
		&\leq 
		\frac{1}{2} \sum_{(u,v)}\left| \PP(X_1=u)\left(\PP(X_2=v) - \PP(Y_2 = v)\right)
		- (\PP(X_1 = u) - \PP(Y_1=u))\PP(Y_2=v) \right| \\
		&\leq
		\frac{1}{2} \sum_{(u,v)} \PP(X_1 = u)
		\left|\left(\PP(X_2=v) - \PP(Y_2 = v)\right) \right| + 
		\frac{1}{2} \sum_{(u,v)}\PP(Y_2=v)\left|(\PP(X_1 = u) - \PP(Y_1=u)) \right| \\
		&= \SD(X_1, Y_1) + \SD(X_2, Y_2)
	\end{align*}
	\end{proof}
	\begin{prop}
	Si deux familles de distributions sont statistiquement
	indistinguables, elles sont calculatoirement indistinguables.
	\end{prop} 

	Le lemme suivant correspond au Claim 5.2 présent dans~\cite{STOC:Regev05}
	et nous sera utile pour la suite.

	\begin{lemme}
	Soit $G$ un groupe abélien fini. Pour $r > 1$ et 
	$\mathcal{F} \subset (g_1, \ldots, g_r) \in G^r$, on
	note
	 $s_\mathcal{F}$ la distribution aléatoire qui à un aléa
	 fait correspondre la somme $\sum_{i\in X} g_i$ pour un
	 sous-ensemble choisi de façon uniforme  $X\subset \llbracket
	 1, r \rrbracket$. 
	 D'autre part, on considère la distribution uniforme
	 $U$ sur $G$
	 Alors, on a: 
	 \[\mathbb{E}_{\mathcal{F}\subset G^r}(SD(s_\mathcal{F},U)) \leq 
	   \sqrt{\frac{|G|}{2^r}}\]
	 Notamment, 
	 \[\mathbb{P}\left(SD(s_\mathcal{F},U) \geq
		 \sqrt[\leftroot{-3}\uproot{8}4\:]{\frac{|G|}{2^r}} \right) \leq
		 \sqrt[\leftroot{-3}\uproot{8}4\:]{\frac{|G|}{2^r}}
	 \]
	\end{lemme}
	\begin{proof}
		Remarquons que:
	\begin{align*}
		\sum_{h\in G} {\PP(s_F = h)}^2 &= 
		\PP\left(\sum_i b_i g_i = \sum_i b'_i g_i\right) \\
		& \leq \frac{1}{2^l} + \PP
		\left( \sum_i b_i g_i = \sum_i b'_i g_i |\:\: (b_i)_i \neq
		(b'_i)_i \right)
	\end{align*}
	Or, pour $(b_i)_i \neq (b'_i)_i$, 
		\[ \PP\left((g_i)_i\: :\: \sum_i b_i g_i = \sum_i b'_i
		g_i\right) = \frac{1}{|G|}\]
	D'où on déduit que:
	\[\mathbb{E}_\mathcal{F}\left(\sum_h {\PP(s_{\mathcal{F}} =
	h)}^2\right) \leq \frac{1}{2^l} + \frac{1}{|G|} \]

	Ce qui implique que:

\begin{align*}
\mathbb{E}_\mathcal{F}\left[ \sum_h\Big| \PP(s_F = h) - 1/|G|\Big| \right] 
&\leq
\mathbb{E}_\mathcal{F}
\left[ 
	{|G|}^{1/2}
	{ \left( \sum_h {\left(\PP(s_F = h) - 1/|G|\right)}^2
	\right)}^{1/2}
\right] 
\\
&= \sqrt{|G|} \:\:
\mathbb{E}_\mathcal{F}
	\left[ 
	{\left( \sum_h {\PP(s_F = h)}^2 - 1/|G|\right)}^{1/2} 
	\right] \\
&\leq \sqrt{|G|} \:\:
{\left( 
	\mathbb{E}_\mathcal{F}\left[ \sum_h  {\PP(s_F = h)}^2  \right]
- \frac{1}{|G|}
\right)}^{1/2} \\
	&\leq \sqrt{\frac{|G|}{2^l}}
\end{align*}

\end{proof}

	\begin{cor}
	Soit $G$ un groupe abélien fini. Pour $r > 1$ et 
	$\mathcal{F} \subset (g_1, \ldots, g_r) \in G^r$, on
	note
	 $s_\mathcal{F}$ la distribution aléatoire qui à un aléa
	 fait correspondre la somme $\sum_{i\in X} g_i$ pour un
	 sous-ensemble choisi de façon uniforme  $X\subset \llbracket
	 1, r \rrbracket$. 
	 Considérons alors le n-uplet $S_\mathcal{F} = (X_1, \ldots, X_r)$ où 
	 les $X_i$ sont indépendants de même loi
	 $s_\mathcal{F}$.
	 D'autre part, on considère la distribution uniforme
	 $U$ sur $G^r$
	 Alors, on a: 
	 \[\mathbb{E}_{\mathcal{F}\subset G^r}(SD(s_\mathcal{F},U)) \leq 
	   \sqrt{r^2\frac{|G|}{2^r}}\]
	 Notamment, 
	 \[\mathbb{P}\left(SD(s_\mathcal{F},U) \geq
		 \sqrt[\leftroot{-3}\uproot{8}4\:]{r^2\frac{|G|}{2^r}} \right) \leq
		 \sqrt[\leftroot{-3}\uproot{8}4\:]{r^2\frac{|G|}{2^r}}
	 \]
	\end{cor}
	\begin{proof}
		Découle directement de la proposition précédente ainsi que de
		la proposition \ref{sd_add}
	\end{proof}

	\begin{prop}
	Supposons avoir pris des paramètres $(n, q, \chi, m)$
	tels que l'hypothèse $\LWE$ soit vraie. Alors pour $\tau >0$
	et $m > (1+\tau)(n+1)\log(q)$ et $m = \mathcal{O}(n\log(q))$ , la distribution jointe
	$(A, RA)$ est calculatoirement indistinguable de la
	distribution uniforme sur $\ZZq^{m \times (n+1)} \times \ZZq^{N
	\times (n+1)}$
	\end{prop}
	\begin{proof}
	On peut deja voir que comme $A$ est calculatoirement
	indistinguable de $U$, $(A, RA)$ l'est de $(U,RU)$ car on 
	peut facilement créer $(A, RA)$ (resp. $(U, RU)$) à partir de
	$A$ (resp. $U$).

	Il nous faut donc monter que $\mathcal{D}_1 = (U, RU)$ est calculatoirement
	indistinguable de $\mathcal{D}_2 = (U, V)$ où $V$ est uniforme.
	
	On peut alors utiliser le lemme précédent avec $G = \ZZq^{n+1}$
	et $r = m$ afin de voir qu'il echiste une constante $\lambda > 0$
	telle que:
	\[\mathbb{E}_{\mathcal{U}\subset \ZZq^{m\times n+1}}(SD(RU,V)) \leq 
		\sqrt{m^2\frac{q^{n+1}}{2^m}}\leq \lambda
	n\log(q)\sqrt{\frac{1}{q^{\tau(n+1)}}}=: f(n) \]
	Et, notant $Y = \{ U: \SD(RU,V) \geq \sqrt{f(n)}\}$, on obtient:
	\[\PP(U \in Y) \leq \sqrt{f(n)} \]
	où $f$ est négligeable en $n$. 



	
	Soit $(x,y)\in \ZZq^{m \times (n+1)} \times \ZZq^{m \times (n+1)}$
	\begin{align*}
	&\left|\PP(D_1 = (x,y)) - \PP(D_2 = (x,y))\right| \\ &\leq \PP(x\in Y)\:
	\Big|\PP(D_1 
	= (x,y)| x\in Y) - \PP(D_2 = (x,y)|x\in Y)\Big| + \PP(x \not\in Y)  \\
	&\leq |\PP(D_1 = (x,y) | x \in Y) - \PP(D_2 = (x,y)|x \in Y)| + \sqrt{f(n)} \\
	&\leq 2\sqrt{f(n)} 
	\end{align*}
	
	Ainsi, il n'est pas possible qu'un automate $\mathcal{A}$
	polynomial probabiliste puisse distinguer 
	$\mathcal{D}_1$ de $\mathcal{D}_2$ car elle sont statistiquement 
	indistinguables.
	\end{proof}
	\begin{thm}
	\label{ind_cpa}
	Sous les hypothèses de la proposition précédente, le
	cryptosysteme est IND-CPA.
	\end{thm}
	\begin{proof}
	Comme un automate polynomial probabiliste ne peut pas distinguer
	$A_{s, \chi}$ de la distribution uniforme, on peut supposer que la
	clé publique $A$ est uniforme.

	Considérons alors un chiffré 
	\[C = \flatten\left(\mu \cdot \id_N + \bitdecomp(R\cdot A)\right) \in
	\ZZq^{N\times N}\]

	On a:
	\[ \bitdecomp^{-1}(C) = \mu * \bitdecomp(\id_N) + R\cdot A\]

	Par la proposition précédente, un automate polynomial probabiliste $\mathcal{A}$
	ne peut pas distinguer $R\cdot A$ d'une matrice uniforme. On peut donc
	supposer que $R\cdot A$ est uniforme, et que le chiffrement est donc
	un one-time pad.

	On en déduit qu'il n'existe pas d'automate polynomial probabiliste
	$\mathcal{A}$ permettant de déchiffrer efficacement les chiffrés de ce cryptosystème.
	\end{proof}
	
	\end{subsection}

	Nous allons maintenant nous intéresser au choix de paramètres de notre
	cryptosystème. C'est une étape cruciale de la mise en place de celui-ci,
	car ce sont eux qui détermineront les degrés de sécurités et la profondeur des circuits calculables.
	
	Sur ce point, deux approches sont possibles: une étude asymptotique ou
	bien une étude \og concrète \fg~ des paramètres.

	Nous nous interesserons ici uniquement à l'algorithme de déchiffrement
	\textbf{Dec}, nous ne considèrerons donc que des chiffrés de $0$ ou
	$1$ et nous interesserons principalement à la profondeur maximale 
	possible de NAND permettant encore de déchiffrer.

	\begin{subsection}{Choix asymptotique de paramètres pour un leveled GSW}
	\label{param_leveled}
	Les indications faites dans l'article original \cite{EPRINT:GenSahWat13} n'étaient pas très explicites; nous nous inspirons donc ici du travail
	effectué par Shai Haleva dans \cite{halevi} pour avoir un jeu de
	contraintes nous permettant des paramètres permettant de faire un
	leveled GSW. 

	Rappelons que nous avons déjà pris pour hypothèse que le problème DLWE est difficile avec les paramètres suivants:
	\[ q \approx 2^{n^\epsilon}\quad \alpha q = n\quad \text{$m$ polynomial en $n$}\]
	De plus, le théorème~\ref{ind_cpa} necessite d'avoir 
	\[m > (1+\tau)(n+1)\log(q) \]
	pour un $\tau > 0$ pour que le cryptosystème soit IND-CPA.  Nous prenons alors: 
	\[ m = 2(n+1)(\lfloor \log(q) \rfloor + 1) = 2(N + \bnorm{q}) < 2
	\bnorm{q} (N+1)\]
	Enfin, nous devons aussi respecter la condition de longueur pour pouvoir appliquer une profondeur de $L$ NAND à notre chiffré:
	\[q > 8nm (1 + N)^L \]

En utilisant notre inégalité sur $m$  dans cette dernière équation, on voit alors qu'il nous suffit d'avoir:

\begin{equation}
q > 16 {(1+N)}^{L+2}
\end{equation}
car alors:
\begin{equation}
q> 8 (8 N (N+1)) {(1 + N)}^{L} > 8 nm {(1 + N)}^L \\
\end{equation}

Ceci nous ammène à premier jeu de contraintes: 
\[ \begin{cases}\alpha  = n \cdot 2^{-n^\epsilon}=  \\
	q = \lceil 2^{n^\epsilon}\rceil\\ 
	m = 2(N + \bnorm{q}) \\  
	n^\epsilon > 4 + (L+2) \log\left( 1 + N\right)
	\end{cases} \]

Nous allons encore simplifier la dernière contrainte en utilisant:
\begin{align*} (L+2) \log\left( 1 + N\right) &\leq (L+2) (2 + \log(N)) \\
&\leq (L+2) (2 + \log(n) +  \log(\bnorm{q})) \\
&\leq (L+2) (3 + \log(n) + \log(\log(q))
&\leq 2 L \log(n) \quad \text{pour $n$ assez grand}
\end{align*}

Ce qui au final, nous donne:
\[ \begin{cases}
	\alpha  = n \cdot 2^{-n^\epsilon}=  \\
	q = \lceil 2^{n^\epsilon} \rceil\\ 
	m = 2(N + \bnorm{q}) \\  
	n^\epsilon > 2 L \log(n)
	\end{cases}  \]
Il nous reste donc à trouver une valeur pour $n$, dépendant du paramètre de sécurité $\lambda$.  En posant $n = \rho^{1/\epsilon}$, on voit que la dernière contrainte devient:
\[ \frac{\rho}{\log(\rho)} > \frac{2 L}{\epsilon}  \]
Et en prenant $\rho = \text{cst} a \log(a)$, cela devient:
\[\log(a)> \frac{2 L}{\epsilon\:\text{cst}\: a}\:(\log(a) + \log(\log(a)) + \log(cst))   \]
qui est vérifiée pour $a = L$ et $cst = 4/\epsilon$ car alors, on obtient:
\begin{align*}
& \log(L)> \frac{1}{\text{2}}\:(\log(L) + \log(\log(L)) + 2 - \log(\epsilon)) \\
&\Leftrightarrow  \log(L) - \log(\log(L)) - 2 > \log(\frac{1}{\epsilon})
\end{align*}
ce qui est vrai pour $L$ assez grand.  

\begin{align*}
\Leftrightarrow  \log(L) - \log(\log(L)) - 2 > 0
\end{align*}
	qui est une fonction croissante en $L$, et positive dés $L = 20$.  Notons enfin que ce choix de valeur $n$ est indépendant du paramètre de sécurité $\lambda$, on peut donc prendre le maximum entre les deux valeurs pour plus de cohérence.  

On en déduit le théorème suivant:
\begin{thm}{leveled GSW}
	Pour $L$ et $\lambda$ assez grands, et sous l'hypothèse sur DWLE~(page \pageref{hyp_dwle}), les paramètres suivants permettent de faire une profondeur de NAND de $L$
et rendent le cryptosystème GSW IND-CPA:
\[ \begin{cases} 
	n = \max\left(\lambda, \lceil 4/\epsilon \log(L) \log(\log(L))
	\rceil\right)  \\
	\alpha  = n \cdot 2^{-n^\epsilon}  \\
	q = \lceil 2^{n^\epsilon} \rceil\\ 
	m = 2(N + \bnorm{q}) \\  
	\end{cases}  \]
\end{thm}
Remarquons toutefois qu'il s'agit uniquement de paramètres \og théoriques \fg~ \ étant donné que la sécurité n'est assurée qu'asymptotiquement.


	\end{subsection}

	\begin{subsection}{Choix de paramètres concrets pour un leveled GSW}
	\begin{subsubsection}{Présentation de lwe\_estimator}
	
	Initialement utilisé dans l'article
	\cite{EPRINT:AlbPlaSco15},\path{lwe_estimator}
	(disponible à l'adresse \cite{estimator}) est un module de sagemath actuellement maintenu par
Martin Albrecht et 
	destiné à estimer la résistance face à diverses attaques de paramètres précis pour
	le problème de learning with error.

	Nous avons pensé qu'il pouvait être interessant de l'utiliser afin de
	voir si nous pouvions trouver des paramètres offrants une sécurité
	concrète, et non uniquement une famille de paramètres offrant une
	sécurité asymptotique.
	
	
	\paragraph{}
	\textbf{estimate\_lwe :}

	\paragraph{}
	Pour estimer la résistance de paramètres choisis sur un panel
	d'attaques, on utilise la fonction \path{estimate_lwe} dont une sortie
	typique est:
	
	\flushleft
	
	\begin{lstlisting}
estimate_lwe(n, alpha=None, q=None, secret_distribution=True, m=oo,
             reduction_cost_model=reduction_default_cost,
             skip=("mitm", "arora-gb", "bkw"))
        \end{lstlisting}
	
	\flushleft
	
	Cette dernière prends en arguments les paramètres usuels de LWE, n, $\alpha$ et q, ainsi que d'autres arguments optionnels et rend plusieurs résultats dont le sens n'est pas forcément évident.
	En fait, elle retourne tout un ensemble de variables pour chaque attaque vérifiée. Le module
	contient 6 attaques différentes, mais n'en testera que trois par defaut. Cela peut être modifié
	lorsque l'on appelle la fonction \path{estimate_lwe} via l'argument skip.
	
	\flushleft
	
	\begin{figure}
	\label{fig:seal_estimate}
	\begin{lstlisting}[mathescape=true]
sage: load("estimator.py")
sage: n = 2048; q = 2^60 - 2^14 + 1; $\alpha$ = 8/q; m = 2*n
sage: _ = estimate_lwe(n, $\alpha$, q, secret_distribution=(-1,1), 
	  reduction_cost_model=BKZ.sieve, m=m)
usvp: rop: =2^115.5,  red: =2^115.5,  $\delta_0$: 1.004975,  
      $\beta$:  288,  d: 4013,  m: 1964
 dec: rop: =2^127.1,  m:  =2^11.1,  red: =2^127.1,  $\delta_0$: 1.004663,  
      $\beta$: 318, d: 4237,  
      babai: =2^114.8,  babai_op: =2^129.9,  repeat: 7,  $\epsilon$: 0.500000
dual: rop: =2^118.4,  m:  =2^11.0,  red: =2^118.4,  $\delta_0$: 1.004864,  
      $\beta$: 298,  
      repeat:  =2^58.8,  d: 4090,  c:    3.909,  k: 30, postprocess: 13
	\end{lstlisting}
	\caption{Analyse de sécurité des paramètres tirés de la librairie SEAL}
	\end{figure}
	\flushleft
	
	Les variables rendues pour chaque attaques ne sont pas toutes utiles, certaines étant strictement internes à ces attaques. Les trois variables qui nous intéresse sont : "rop", "m" et "mem" :
	
	\begin{itemize}
	\item "rop" (ring operations) est une estimation du nombre d'opérations à effectuer afin de résoudre ce cas de LWE avec cette attaque.
	
	\item "mem" (memory) est une estimation de la mémoire qui sera exploitée.
	
	\item "m" indique le nombre d'échantillons nécessaires pour résoudre le problème avec ces valeurs de
	"rop" et "mem". A noter que l'on peut limiter le nombre d'échantillons disponibles pour l'attaquant
	lorsqu'on appelle \path{estimate_lwe}.
	\end{itemize}

	le module \path{sage.crypto.lwe} contient des choix de paramètres pour
	le problème LWE, dont deux qui utilisent la gaussienne discrète
	\footnote{un autre utilise la distribution uniforme}
	et que nous allons présenter ici. Notons que nous avons pour cela 
	regardé les codes 
	sources des fonctions sage, disponibles dans leur github (\cite{sage}).
	\end{subsubsection}

	\begin{subsubsection}{Proposition de choix sécurité pour très faible profondeur}
	\paragraph{}
	En utilisant les paramètres suivants, tirés de l'API SEAL:
	\[n = 2048\quad q = 2^{60} - 2^{14} + 1 \quad \alpha = \frac{8}{q}\quad m = 2n \]
	On voit que l'estimation proposée par lwe indique  l'attaque la plus rapide demande $2^{115}$ opérations de base dans l'anneau $\ZZq$, soit un facteur de sécurité de 115. De plus, l'équation~\eqref{depth} indique qu'une profondeur de NAND $L=3$ est possible. \\
	On a ici un secret de 15 Ko, une clé publique de 7.6 Mo et des chiffrés de 13 Go.

	\paragraph{}
	En utilisant les paramètres suivants, tirés de \cite{cryptoeprint:2015:755}:
	\[n = 804\quad  q = 2^{31} - 19\quad \alpha = \frac{\sqrt{2\pi}*57}{q} \quad m = 4972\]
	On voit que l'estimation proposée par lwe indique  l'attaque la plus rapide demande $2^{129}$ opérations de base dans l'anneau $\ZZq$, soit un facteur de sécurité de 129. De plus, l'équation~\eqref{depth} indique qu'une profondeur de NAND $L=1$ est possible. \\
	On a ici un secret de 3 Ko, une clé publique de 5 Mo et des chiffrés de 2 Go.
	\end{subsubsection}

	\end{subsection}
\end{section}
