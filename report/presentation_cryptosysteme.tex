\begin{section}{Présentation du cryptosystème}
	\begin{subsection}{L'idée générale}
	L'idée de ce cryptosystme consiste à prendre pour secret un
	certain vecteur $\vec{v} \in \ZZq^N$ pour certains paramètres
	$q, N \in \NN$, puis à chiffrer un message $m \in \ZZq$ à
	l'aide d'une matrice $C \in \ZZq^{N \times N}$ ayant $m$ pour valeur propre 
	associée au vecteur propre $\vec{v}$. Autrement dit, avec:
	\[C \cdot \vec{v} = m \vec{v}\: \mod q \]

	De là, il est facile de voir que pour $\lambda \in \ZZ$ et  $C_1$ et $C_2$ 
	chiffrés de $m_1$ et $m_2$, on a :
	\begin{align*}
	& (C_1 + C_2) \cdot \vec{v} = (m_1 + m_2) \vec{v} \\
	& (C_1 \times C_2) \cdot \vec{v} = (m_1 + m_2) \vec{v} \\
	& (\lambda  C_2) \cdot \vec{v} = (\lambda m_1) \vec{v} 
	\end{align*}

	Toutefois, un tel système n'est pas sécurisé car $C$ n'a qu'un nombre
	fini de valeurs propres, et il semble donc facile de 
	retrouver le secret $\vec{v}$.

	La solution consiste alors à ajouter du bruit au chiffré, c'est à dire
	à chiffrer $m\in \ZZq$ par une matrice $C \in \ZZ^{N \times N}$
	telle que:
	\[ C \vec{v} = m \vec{v} + \vec{e} \]
	pour une \og petite \fg erreur $\vec{e}$. Si le vecteur
	$\vec{v}$ contient un grand coefficient $v_i$, on voit alors qu'il 
	reste possible de retrouver $m$ avec
	\begin{align*}
	\frac{{(C \vec{v})}_i}{v_i} = \frac{m + e_i}{v_i}
	\end{align*}
	
		Nous verrons que pour de bons
	choix de paramètres, déchiffrer un tel message permet de
	résoudre une instance de LWE.

	Toutefois, l'ajout d'une erreur comporte ses inconvénients. Si nous
	revenons aux équations précédentes, en introduisant les erreurs 
	$\vec{e}_i$ pour chiffrer  $m_i$ ($i\in \{1,2\}$), on obtient :

	\begin{align*}
	& (C_1 + C_2) \cdot \vec{v} = (m_1 + m_2) \vec{v} + (\vec{e}_1 + \vec{e}_2)\\
		& (C_1 \times C_2) \cdot \vec{v} = (m_1 * m_2) \vec{v} + C_1
		\vec{e}_2 + m_2\vec{e}_1 \\
	& (\lambda  C_2) \cdot \vec{v} = (\lambda m_1) + \lambda e_i\vec{v} 
	\end{align*}

	Notamment, on voit que le terme $C_1 * \vec{e}_2$ peut être très grand 
	même pour un petit $\vec{e}_2$. Nous verrons par la suite comment
	choisir nos paramètres, et notamment $\vec{v}$, afin de 
	toujours pouvoir se ramener à des chiffrés $C \in \{0,1\}^{N
	\times N}$. De cette façon, on aura:

	
	
	




		% Explication sans l'erreur, pourquoi c'est homomophique
	\end{subsection}
	\begin{subsection}{Fonctions utilisées}
	Plusieurs algorithmes seront utiles pour pouvoir bien définir le système FHE :
	
	\paragraph{}
	\textbf{BitDecomp}
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée un vecteur $\vec{a} = (a_1, ..., a_k) \in \ZZq^{k}$. \\
	\textbf{Sortie} : Cet algorithme retourne la décomposition binaire des éléments de $\vec{a}$ sous la forme d'un vecteur. \\
	\textbf{Algorithme} : Pour chaque $a_i$, on détermine sa représentation binaire avec les bits de faibles puissance à gauche et non à droite. On retourne la concaténation de ces représentations binaires sous la forme d'un vecteur.
	
	\paragraph{}
	\textbf{BitDecomp}$^{-1}$
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée un vecteur $\vec{a} = (a_{1,0}, ..., a_{1,l-1}, a_{2,0}, ..., a_{k,l-1})$. \\
	\textbf{Sortie} : Cet algorithme renvoie ($\sum\limits_{i=0}^{l-1} 2^{i} a_{1,i}, ..., \sum\limits_{i=0}^{l-1} 2^{i} a_{k,i})$. \\
	\textbf{Remarque} : Si tous les $a_{i,j}$ sont dans $\{ 0,1 \} $, cet algorithme inverse bien \textbf{BitDecomp}, cependant, sa définition ne le limite pas aux vecteurs $\in \{ 0,1\} ^{k\times l}$.

	\paragraph{}
	\textbf{Flatten}
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée un vecteur $\vec{a} = (a_{1,0}, ..., a_{1,l-1}, a_{2,0}, ..., a_{k,l-1})$. \\
	\textbf{Sortie} : Cet algorithme retourne un vecteur $\vec{b} = (b_{1,0}, ..., b_{1,l-1}, b_{2,0}, ..., b_{k,l-1})$ dont les éléments sont tous dans $\{ 0,1\} $. \\
	\textbf{Algorithme} : On calcule \textbf{BitDecomp}$^{-1}(\vec{a})$ et on obtient un vecteur $\vec{z} \in \ZZq^{k}$. On applique ensuite \textbf{BitDecomp} à $\vec{z}$ et l'on renvoie le résultat obtenu.
	
	\paragraph{}
	\textbf{PowersOf2}
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée un vecteur $\vec{a} = (a_1, ..., a_k) \in \ZZq^{k}$. \\
	\textbf{Sortie} : Cet algorithme renvoie ($a_1, 2 a_1, 2^{2} a_1, ..., 2^{l-1} a_1, a_2, ..., 2^{l-1} a_k)$. \\
	
	\begin{prop}
	Soient $\vec{a}$ et $\vec{b}$ dans $\ZZq^{k}$. \\
	On a $\langle \textbf{BitDecomp}(\vec{a}), \textbf{PowersOf2}(\vec{b}) \rangle = \langle\vec{a},\vec{b} \rangle$.
	\end{prop}
	\begin{proof}
	\begin{align*}
	\langle \textbf{BitDecomp}(\vec{a}), \textbf{PowersOf2}(\vec{b}) \rangle &= \sum\limits_{i=1}^{k} \sum\limits_{j=0}^{l-1} a_{i,j} * (2^{j} * b_i) \\
	&= \sum\limits_{i=1}^{k} b_i * \sum\limits_{j=0}^{l-1} (a_{i,j} * 2^{j}) \\
	&= \sum\limits_{i=1}^{k} b_i * a_i \\
	&= \langle\vec{a},\vec{b} \rangle.
	\end{align*}
	\end{proof}
	
	\begin{prop}
	Soient $\vec{a}$ dans $\ZZq^{k \times l}$ et $\vec{b}$ dans $\ZZq^{k}$. \\
	On a $\langle \vec{a}, \textbf{PowersOf2}(\vec{b}) \rangle = \langle \textbf{BitDecomp}^{-1}(\vec{a}), \vec{b}\rangle = \langle \textbf{Flatten}(\vec{a}),\textbf{PowersOf2}(\vec{b}) \rangle$. \\
	\end{prop}
	\begin{proof}
	\begin{align*}
	\langle \vec{a}, \textbf{PowersOf2}(\vec{b}) \rangle &= \sum\limits_{i=1}^{k} \sum\limits_{j=0}^{l-1} a_{j+li} * (2^{j} * b_i) \\
	&= \sum\limits_{i=1}^{k} b_i * \sum\limits_{j=0}^{l-1} (a_{j+li} * 2^{j}) \\
	&= \langle \textbf{BitDecomp}^{-1}(\vec{a}), \vec{b}\rangle \\
	\end{align*}
	Soit $c = \textbf{BitDecomp}^{-1}(\vec{a})$.
	\begin{align*}
	\langle \textbf{Flatten}(\vec{a}),\textbf{PowersOf2}(\vec{b}) \rangle &= \langle \textbf{BitDecomp}(\vec{c}),\textbf{PowersOf2}(\vec{b}) \rangle \\
	&= \sum\limits_{i=1}^{k} \sum\limits_{j=0}^{l-1} c_{i,j} * (2^{j} * b_i) \\
	&= \sum\limits_{i=1}^{k} b_i * \sum\limits_{j=0}^{l-1} (c_{i,j} * 2^{j}) \\
	&= \sum\limits_{i=1}^{k} b_i * c_i \\
	&= \langle \textbf{BitDecomp}^{-1}(\vec{a}), \vec{b}\rangle \\
	&= \langle \vec{a}, \textbf{PowersOf2}(\vec{b}) \rangle
	\end{align*}
	\end{proof}
	
	\end{subsection}
	\begin{subsection}{Définition du cryptosystème}
	On rappelle que les paramètres du système défini ici sont : le paramètre de dimension $n$, le modulus $q$, un modèle de distribution de l'erreur $\chi$ ainsi que $m$, qui, tout comme $n$ influera la taille des matrices manipulées. \\
	On note $l = \lfloor$log $q\rfloor + 1$ et $N = (n + 1)$ $l$.
		
	\paragraph{}
	\textbf{Setup}
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée $1^\lambda$ et $1^L$ avec $\lambda$ paramètre de sécurité et L paramètre de profondeur. \\
	\textbf{Sortie} : Cet algorithme retourne les paramètres $n, q, \chi, m$ du système. \\
	\textbf{Algorithme} : On définit des paramètres permettant de pouvoir effectuer au moins L opérations sur un chiffré et de toujours pouvoir le déchiffrer correctemment tout en assurant qu'un adversaire attaquant le système doive effectuer au moins $2^\lambda$ opérations, quelle que soit l'attaque qu'il choisisse. La façon de déterminer ces paramètres n'est pas définie afin de pouvoir l'adapter suivant l'evolution des attaques. \\
	
	\paragraph{}
	\textbf{SecretKeyGen}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme n'a besoin en entrée que des paramètres donnés par \textbf{Setup}. \\
	\textbf{Sortie} : Cet algorithme retourne la clé secrète $\vec{s} \in \ZZq^{n+1}$. \\
	\textbf{Algorithme} : On génère aléatoirement un vecteur $\vec{t} \in \ZZq^n$. On définit la clé secrète comme $\vec{s} = (1, -t_1, ..., -t_n)$. \\
	On note $\vec{v} = $ \textbf{PowersOf2}$(\vec{s})$.
	
	\paragraph{}
	\textbf{PublicKeyGen}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme n'a besoin en entrée que des paramètres donnés par \textbf{Setup} et d'une clé secrète construite avec ces mêmes paramètres. \\
	\textbf{Sortie} : Cet algorithme retourne la clé publique $A \in \ZZq^{m \times n}$.\\
	\textbf{Algorithme} : On génère une matrice uniforme $B \in \ZZq^{n \times m}$ et un vecteur $\vec{e}$ de m éléments choisis suivant la distribution $\chi$. On définit $\vec{b} = B \times \vec{t} + \vec{e}$. La clé publique est la matrice constituée de l'indentation de $\vec{b}$ considéré comme un vecteur colonne et de $B$.
	
	\paragraph{}
	\textbf{Encrypt}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme prend en entrée les paramètres du système, la clé publique et un message $\mu \in \ZZq$. \\
	\textbf{Sortie} : Cet algorithme retourne le chiffré $C \in \ZZq^{N \times N}$ de $\mu$.\\
	\textbf{Algorithme} : On génère uniformément une matrice $R \in \{ 0,1\} ^{N \times m}$. Le chiffré est : $C = $ \textbf{Flatten}$(\mu \times I_N + $\textbf{BitDecomp}$(R \times A))$.
	
	\paragraph{}
	\textbf{Dec}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme prend en entrée les paramètres du système, la clé secrète et un chiffré d'un message $\mu \in \{ 0,1\} $. \\
	\textbf{Sortie} : Cet algorithme retourne le clair du chiffré si l'erreur de ce dernier n'est pas trop élevée.\\
	\textbf{Algorithme} : On rappelle que les $l$ premiers coefficients de $\vec{v}$ sont les puissances de 0 à $l-1$ de 2. Soit $i \leqslant l$ tel que le i+1ème coefficient de $\vec{v}$, égal à $2^{i}$, soit compris entre $\frac{q}{4}$ et $\frac{q}{2}$, $\frac{q}{2}$ compris. On note $C_i$ la ième ligne de $C$. On calcule ensuite $x_i = \langle C_i, \vec{v} \rangle$ et on renvoie $\lfloor \frac{x_i}{v_i} \rceil$.
	\end{subsection}
	
	\begin{subsection}{Opérations homomorphes}
	On rappelle que $\vec{v}$ est de la forme $\textbf{PowersOf2}(\vec{s})$ et que donc $\textbf{Flatten}(A) \cdot \vec{v} = A \times \vec{v}$ pour tout $A$.
	
	\paragraph{}
	\textbf{MultConst}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme prend en entrée les paramètres du système, un chiffré $C \in \ZZq^{N \times N}$ d'un message $\mu$ et une constante $\alpha \in \ZZq$. \\
	\textbf{Sortie} : Cet algorithme retourne un chiffré de $\alpha \cdot \mu$.\\
	\textbf{Algorithme} : On calcule $M_{\alpha} = \textbf{Flatten}(\alpha \times I_N)$ puis l'on renvoie $\textbf{Flatten}(M_{\alpha} \times C)$.
	\begin{proof}
	\begin{align*}
	\textbf{MultConst}(C, \alpha) \times \vec{v} &= M_{\alpha} \times C \times \vec{v} \\
	&= M_{\alpha} \cdot (\mu * \vec{v} + \vec{e}) \\
	&= M_{\alpha} \times \mu * \vec{v} + M_{\alpha} \times \vec{e} \\
	&= \alpha * \mu * \vec{v} + M_{\alpha} \times \vec{e}
	\end{align*}
	\end{proof}
	\textbf{Erreur} : Le chiffré à une erreur de $M_\alpha \times \vec{e}$. L'impact de celle-ci sur le déchiffrement sera donc au maximum de $N$ fois l'impact de $\vec{e}$ quel que soi $\alpha$.
	
	\paragraph{}
	\textbf{Add}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme prend en entrée les paramètres du système et deux chiffrés $C_1, C_2 \in \ZZq^{N \times N}$ des messages $\mu_1, \mu_2 \in \ZZq$.\\
	\textbf{Sortie} : Cet algorithme retourne un chiffré de $\mu_1 + \mu_2$.\\
	\textbf{Algorithme} : On calcule et on retourne $\textbf{Flatten}(C_1 + C_2)$.
	\begin{proof}
	\begin{align*}
	\textbf{Add}(C_1, C_2) \times \vec{v} &= (C_1 + C_2) \times \vec{v} \\
	&= (\mu_1 * \vec{v} + \vec{e_1}) + (\mu_2 * \vec{v} + \vec{e_2}) \\
	&= (\mu_1 + \mu_2) * \vec{v} + \vec{e_1} + \vec{e_2}
	\end{align*}
	\end{proof}
	\textbf{Erreur} : Le chiffré à une erreur de $\vec{e_1} + \vec{e_2}$. L'impact de celle-ci sur le déchiffrement sera donc au maximum de la somme de l'impact de $\vec{e_1}$ et de l'impact de $\vec{e_2}$.
	
	\paragraph{}
	\textbf{Mult}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme prend en entrée les paramètres du système et deux chiffrés $C_1, C_2 \in \ZZq^{N \times N}$ des messages $\mu_1, \mu_2 \in \ZZq$.\\
	\textbf{Sortie} : Cet algorithme retourne un chiffré de $\mu_1 * \mu_2$. \\
	\textbf{Algorithme} : On calcule et on retourne $\textbf{Flatten}(C_1 \times C_2)$.
	\begin{proof}
	\begin{align*}
	\textbf{Mult}(C_1, C_2) \times \vec{v} &= (C_1 \times C_2) \times \vec{v} \\
	&= C_1 \times (\mu_2 * \vec{v} + \vec{e_2}) \\
	&= \mu_2 * C_1 \times \vec{v} + C_1 \times \vec{e_2} \\
	&= \mu_2 * (\mu_1 * \vec{v} + \vec{e_1}) + C_1 \times \vec{e_2} \\
	&= (\mu_1 * \mu_2) * \vec{v} + \mu_2 * \vec{e_1} + C_1 \times \vec{e_2}
	\end{align*}
	\end{proof}
	\textbf{Erreur} : Le chiffré à une erreur de $\mu_2 * \vec{e_1} + C_1 \times \vec{e_2}$. La matrice $C_1$ étant de la forme $\textbf{Flatten}(c_1)$, elle ne contient que des 0 et des 1. $C_1 \times \vec{e_2}$ a donc un impact sur le déchiffrement d'au maximum $N$ fois l'impact de $\vec{e_1}$. $\mu_2 * \vec{e_1}$ n'a pas ce genre de contrainte et son impact maximum ne peut guère être limité qu'en limitant les valeurs des messages.
	
	\paragraph{}
	\textbf{NAND}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme prend en entrée les paramètres du système et deux chiffrés $C_1, C_2 \in \ZZq^{N \times N}$ des messages $\mu_1, \mu_2 \in \{ 0,1\}$.\\
	\textbf{Sortie} : Cet algorithme retourne un chiffré de $\overline{(\mu_1 \land \mu_2)} = 1 - \mu_1 * \mu_2$. \\
	\textbf{Algorithme} : On calcule et on retourne $\textbf{Flatten}(I_N - C_1 \cdot C_2)$.
	\begin{proof}
	\begin{align*}
	\textbf{NAND}(C_1, C_2) \times \vec{v} &= (I_N - C_1 \times C_2) \times \vec{v} \\
	&= \vec{v} - \textbf{Mult}(C_1, C_2) \\
	&= \vec{v} - (\mu_1 * \mu_2) * \vec{v} - \mu_2 * \vec{e_1} + C_1 \times \vec{e_2} \\
	&= (1 - \mu_1 * \mu_2) * \vec{v} - \mu_2 * \vec{e_1} - C_1 \times \vec{e_2}
	\end{align*}
	\end{proof}
	\textbf{Erreur} : Le chiffré à une erreur de $-(\mu_2 * \vec{e_1} + C_1 \times \vec{e_2})$. Son impact sur le déchiffrement est donc équivalent à celui d'une opération $\textbf{Mult}(C_1, C_2)$. Cependant, $\mu_2$ étant ici égal à 0 ou 1, on obtient un impact inférieur ou égal à l'impact de $\vec{e_1}$ plus $N$ fois celui de $\vec{e_2}$.
	
	\end{subsection}
\end{section}
