\begin{section}{Présentation du cryptosystème}
	\begin{subsection}{L'idée générale}
	L'idée de ce cryptosystme consiste à prendre pour secret un
	certain vecteur $\vec{v} \in \ZZq^N$ pour certains paramètres
	$q, N \in \NN$, puis à chiffrer un message $m \in \ZZq$ à
	l'aide d'une matrice $C \in \ZZq^{N \times N}$ ayant $m$ pour valeur propre 
	associée au vecteur propre $\vec{v}$. Autrement dit, avec:
	\[C \cdot \vec{v} = m \vec{v}\: \mod q \]

	De là, il est facile de voir que pour $\lambda \in \ZZ$ et  $C_1$ et $C_2$ 
	chiffrés de $m_1$ et $m_2$, on a :
	\begin{align*}
	& (C_1 + C_2) \cdot \vec{v} = (m_1 + m_2) \vec{v} \\
	& (C_1 \times C_2) \cdot \vec{v} = (m_1 + m_2) \vec{v} \\
	& (\lambda  C_2) \cdot \vec{v} = (\lambda m_1) \vec{v} 
	\end{align*}

	Toutefois, un tel système n'est pas sécurisé car $C$ n'a qu'un nombre
	fini de valeurs propres, et il semble donc facile de 
	retrouver le secret $\vec{v}$.

	La solution consiste alors à ajouter du bruit au chiffré, c'est à dire
	à chiffrer $m\in \ZZq$ par une matrice $C \in \ZZ^{N \times N}$
	telle que:
	\[ C \vec{v} = m \vec{v} + \vec{e} \]
	pour une \og petite \fg erreur $\vec{e}$. Si le vecteur
	$\vec{v}$ contient un grand coefficient $v_i$, on voit alors qu'il 
	reste possible de retrouver $m$ avec
	\begin{align*}
	\frac{{(C \vec{v})}_i}{v_i} = \frac{m + e_i}{v_i}
	\end{align*}
	
		Nous verrons que pour de bons
	choix de paramètres, déchiffrer un tel message permet de
	résoudre une instance de LWE.

	Toutefois, l'ajout d'une erreur comporte ses inconvénients. Si nous
	revenons aux équations précédentes, en introduisant les erreurs 
	$\vec{e}_i$ pour chiffrer  $m_i$ ($i\in \{1,2\}$), on obtient :

	\begin{align*}
	& (C_1 + C_2) \cdot \vec{v} = (m_1 + m_2) \vec{v} + (\vec{e}_1 + \vec{e}_2)\\
		& (C_1 \times C_2) \cdot \vec{v} = (m_1 * m_2) \vec{v} + C_1
		\vec{e}_2 + m_2\vec{e}_1 \\
	& (\lambda  C_2) \cdot \vec{v} = (\lambda m_1) + \lambda e_i\vec{v} 
	\end{align*}

	Notamment, on voit que le terme $C_1 * \vec{e}_2$ peut être très grand 
	même pour un petit $\vec{e}_2$. Nous verrons par la suite comment
	choisir nos paramètres, et notamment $\vec{v}$, afin de 
	toujours pouvoir se ramener à des chiffrés $C \in \{0,1\}^{N
	\times N}$. De cette façon, on aura:

	
	
	




		% Explication sans l'erreur, pourquoi c'est homomophique
	\end{subsection}
	\begin{subsection}{Fonctions utiles}
	Plusieurs algorithmes seront utiles pour pouvoir bien définir le système FHE :
	
	\paragraph{}
	\textbf{BitDecomp}
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée un vecteur $\vec{a} = (a_1, ..., a_k) \in \ZZq^{k}$. \\
	\textbf{Sortie} : Cet algorithme retourne la décomposition binaire des éléments de $\vec{a}$ sous la forme d'un vecteur. \\
	\textbf{Algo} : Pour chaque $a_i$, on détermine sa représentation binaire avec les bits de faibles puissance à gauche et non à droite. On retourne la concaténation de ces représentations binaires sous la forme d'un vecteur.
	
	\paragraph{}
	\textbf{BitDecomp}$^{-1}$
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée un vecteur $\vec{a} = (a_{1,0}, ..., a_{1,l-1}, a_{2,0}, ..., a_{k,l-1})$. \\
	\textbf{Sortie} : Cet algorithme renvoie ($\sum\limits_{i=0}^{l-1} 2^{i} \cdot a_{1,i}, ..., \sum\limits_{i=0}^{l-1} 2^{i} \cdot a_{k,i})$. \\
	\textbf{Remarque} : Si tous les $a_{i,j}$ sont dans $\{ 0,1 \} $, cet algo inverse bien \textbf{BitDecomp}, cependant, sa définition ne le limite pas aux vecteurs $\in \{ 0,1\} ^{k\times l-1}$.

	\paragraph{}
	\textbf{Flatten}
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée un vecteur $\vec{a} = (a_{1,0}, ..., a_{1,l-1}, a_{2,0}, ..., a_{k,l-1})$. \\
	\textbf{Sortie} : Cet algorithme retourne un vecteur $\vec{b} = (b_{1,0}, ..., b_{1,l-1}, b_{2,0}, ..., b_{k,l-1})$ dont les éléments sont tous dans $\{ 0,1\} $. \\
	\textbf{Algo} : On calcule \textbf{BitDecomp}$^{-1}(\vec{a})$ et on obtient un vecteur $\vec{z} \in \ZZq^{k}$. On applique ensuite \textbf{BitDecomp} à $\vec{z}$ et l'on renvoie le résultat obtenu.
	
	\paragraph{}
	\textbf{PowersOf2}
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée un vecteur $\vec{a} = (a_1, ..., a_k) \in \ZZq^{k}$. \\
	\textbf{Sortie} : Cet algorithme renvoie ($a_1, 2\times a_1, 2^{2} \times a_1, ..., 2^{l-1} \times a_1, a_2, ..., 2^{l-1} \times a_k)$. \\
	
	\begin{prop}
	Soient $\vec{a}$ et $\vec{b}$ dans $\ZZq^{k}$.
	$\langle \textbf{BitDecomp}(\vec{a}), \textbf{PowersOf2}(\vec{b}) \rangle = \langle\vec{a},\vec{b} \rangle$.
	\end{prop}
	\begin{proof}
	\begin{align*}
	\langle \textbf{BitDecomp}(\vec{a}), \textbf{PowersOf2}(\vec{b}) \rangle &= \sum\limits_{i,j} a_{i,j} \times (2^{j} \times b_i) \\
	&= \sum\limits_{i,j} (a_{i,j} \times 2^{j}) \times b_i \\
	&= \sum\limits_{i} a_i \times b_i \\
	&= \langle\vec{a},\vec{b} \rangle.
	\end{align*}
	\end{proof}
	
	\begin{prop}
	Soient $\vec{a}$ dans $\ZZq^{k \times l}$ et $\vec{b}$ dans $\ZZq^{k}$.
	$\langle \vec{a}, \textbf{PowersOf2}(\vec{b}) \rangle = \langle \textbf{BitDecomp}^{-1}(\vec{a}), \vec{b}\rangle = \langle \textbf{Flatten}(\vec{a}),\textbf{PowersOf2}(\vec{b}) \rangle$. \\
	\end{prop}
	\begin{proof}
	\begin{align*}
	\langle \vec{a}, \textbf{PowersOf2}(\vec{b}) \rangle &= \sum\limits_{i,j} a_{j+li} \times (2^{j} \times b_i) \\
	&= \sum\limits_{i,j} (a_{j+li} \times 2^{j}) \times b_i \\
	&= \langle \textbf{BitDecomp}^{-1}(\vec{a}), \vec{b}\rangle \\
	\end{align*}
	Soit $c = \textbf{BitDecomp}^{-1}(\vec{a})$.
	\begin{align*}
	\langle \textbf{Flatten}(\vec{a}),\textbf{PowersOf2}(\vec{b}) \rangle &= \langle \textbf{BitDecomp}(\vec{c}),\textbf{PowersOf2}(\vec{b}) \rangle \\
	&= \sum\limits_{i,j} c_{i,j} \times (2^{j} \times b_i) \\
	&= \sum\limits_{i,j} (c_{i,j} \times 2^{j}) \times b_i \\
	&= \sum\limits_{i} c_{i} \times b_i) \\
	&= \langle \textbf{BitDecomp}^{-1}(\vec{a}), \vec{b}\rangle \\
	&= \langle \vec{a}, \textbf{PowersOf2}(\vec{b}) \rangle
	\end{align*}
	\end{proof}
	
	\end{subsection}
	\begin{subsection}{Définition du cryptosystème}
	On rappelle que les paramètres du système défini ici sont : le paramètre de dimension $n$, le modulus $q$, un modèle de distribution de l'erreur $\chi$ ainsi que $m$, qui, tout comme $n$ influera la taille des matrices manipulées. \\
	On note $l = \lfloor$log $q\rfloor + 1$ et $N = (n + 1)$ $l$.
		
	\paragraph{}
	\textbf{Setup}
	\flushleft

	\textbf{Entrée} : Cet algorithme prends en entrée $1^\lambda$ et $1^L$ avec $\lambda$ paramètre de sécurité et L paramètre de profondeur. \\
	\textbf{Sortie} : Cet algorithme retourne les paramètres $n, q, \chi, m$ du système. \\
	\textbf{Algo} : On définit des paramètres permettant de pouvoir effectuer au moins L opérations sur un chiffré et de toujours pouvoir le déchiffrer correctemment tout en assurant qu'un adversaire attaquant le système doive effectuer au moins $2^\lambda$ opérations, quelle que soit l'attaque qu'il choisisse. La façon de déterminer ces paramètres n'est pas définie afin de pouvoir l'adapter suivant l'evolution des attaques. \\
	
	\paragraph{}
	\textbf{SecretKeyGen}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme n'a besoin en entrée que des paramètres donnés par \textbf{Setup}. \\
	\textbf{Sortie} : Cet algorithme retourne la clé secrète $\vec{s} \in \ZZq^{n+1}$. \\
	\textbf{Algo} : On génère aléatoirement un vecteur $\vec{t} \in \ZZq^n$. On définit la clé secrète comme $\vec{s} = (1, -t_1, ..., -t_n)$. \\
	On note $\vec{v} = $ \textbf{PowersOf2}$(\vec{s})$.
	
	\paragraph{}
	\textbf{PublicKeyGen}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme n'a besoin en entrée que des paramètres donnés par \textbf{Setup} et d'une clé secrète construite avec ces mêmes paramètres. \\
	\textbf{Sortie} : Cet algorithme retourne la clé publique $A \in \ZZq^{n+1 \times m}$.\\
	\textbf{Algo} : On génère une matrice uniforme $B \in \ZZq^{n \times m}$ et un vecteur $\vec{e}$ de m éléments choisis suivant la distribution $\chi$. On définit $\vec{b} = B \cdot \vec{t} + \vec{e}$. La clé publique est la matrice constituée de l'indentation de $\vec{b}$ considéré comme un vecteur colonne et de $B$.
	
	\paragraph{}
	\textbf{Encrypt}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme prend en entrée les paramètres du système, la clé publique et un message $\mu \in \ZZq$. \\
	\textbf{Sortie} : Cet algorithme retourne le chiffré $C \in \ZZq^{N \times N}$ de $\mu$.\\
	\textbf{Algo} : On génère uniformément une matrice $R \in \{ 0,1\} ^{N \times m}$. Le chiffré est : $C = $ \textbf{Flatten}$(\mu \cdot I_N + $\textbf{BitDecomp}$(R \cdot A))$.
	
	\paragraph{}
	\textbf{Dec}
	\flushleft
	
	\textbf{Entrée} : Cet algorithme prend en entrée les paramètres du système, la clé secrète et le chiffré d'un message $\mu \in \{ 0,1\} $. \\
	\textbf{Sortie} : Cet algorithme retourne le clair du chiffré si l'erreur de ce dernier n'est pas trop élevée.\\
	\textbf{Algo} : On rappelle que les $l$ premiers coeffitiens de $\vec{v}$ sont les puissances de 0 à $l-1$ de 2. Soit $i \leqslant l$ tel que le i+1ème coefficient de $\vec{v}$, égal à $2^{i}$, soit compris entre $\frac{q}{4}$ et $\frac{q}{2}$, $\frac{q}{2}$ compris. On note $C_i$ la ième ligne de $C$. On calcule ensuite $x_i = \langle C_i, \vec{v} \rangle$ et on renvoie $\lfloor \frac{x_i}{v_i} \rceil$.
	\end{subsection}
\end{section}
