\documentclass[10pt,xcolor={usenames,dvipsnames}]{beamer}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% \usepackage{FiraSans}

\usetheme{metropolis}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor} % to have more colors.

% \usepackage{parallel}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{xcolor} % to put colors in equations, ex:  \color{red} ...  or
% \textcolor{red}{foo}: \
\usepackage{wrapfig}
\usepackage{enumerate}

\title{Les FHE, c'est facheux.}
\date{\today}
\author{Lucas Roux \& Eric Sageloli}

% used defined commands
\newcommand{\LWE}{\text{LWE}_{n,q,\chi}}
\newcommand{\DLWE}{\text{DLWE}_{n,q,\chi}}
\newcommand{\SD}{\text{SD}}
\newcommand{\id}{\text{I}}
\newcommand{\flatten}{\text{Flatten}}
\newcommand{\bitdecomp}{\text{BitDecomp}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZq}{\mathbb{Z}_q}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\norm}[1]{{\|#1\|}_{\infty}}
\newcommand{\bnorm}[1]{{|#1|}_{\text{bin}}}

\newcommand{\pk}{\text{pk}}
\newcommand{\sk}{\text{sk}}
\newcommand{\bsk}{\text{bsk}}
\newcommand{\evk}{\text{evk}}
\newcommand{\Dec}{\text{\textbf{Decrypt}}}
\newcommand{\Eval}{\text{\textbf{Eval}}}
\newcommand{\Keygen}{\text{\textbf{Keygen}}}
\newcommand{\Enc}{\text{\textbf{Encrypt}}}

\begin{document}
 \begin{frame} 
 \maketitle
 \end{frame}

%%------------------------------------------------------------------------------------------------


 \begin{frame} 
 \frametitle{Un bref historique}

\begin{itemize}
\item 2009: Un premier plan par Craig Gentry dans sa thèse;
\begin{itemize}
\item idée du bootstrapping;
\end{itemize}
\item 2011: premiers FHE de seconde génération: Z.Brakerski, V.Vaikuntanathan, J.Fan, F.Vercauteren \\
	\begin{itemize}
	\item basés sur LWE et ses variantes (comme RLWE);
	\item une somme simple à définir;
	\item un produit en 2 étapes;\\
	\end{itemize}
\item 2013: premiers FHE de troisième génération: GWS par C.Gentry, B.Waters and A.Sahai, en 2013;
	\begin{itemize}
	\item basés sur LWE et ses variantes;
	\item produit et somme de même nature;
	\end{itemize}
\end{itemize}
\end{frame} 

%%------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{GSW, premier essai:}
\textbf{Clé secrète:} un vecteur $sk \in \ZZq^{N}$ \\
\textbf{Clé publique:} pk\\
\textbf{Chiffrement:} Encrypt(pk, $\mu$) = $C\in \ZZq^{N \times N}\:$ telle que  
\[C \vec{sk} = \vec{s}\]
\vspace{-1cm}

\textbf{Déchiffrement:} Evident \\
\textbf{Opérations homomorphes:}\\
Pour {\small$C_i = \text{Encrypt}(\mu_i) \quad(1 \leqslant i \leqslant 2)$}
et $\lambda \in \ZZq$
\begin{itemize}
\item \textbf{Somme:} $C_1 + C_2\quad$
\[\left(C_1 + C_2\right) \vec{sk} = (\mu_1 + \mu_2)\: \vec{sk}\]
\item \textbf{Produit:} $C_1 \times C_2\quad$
\[\left(C_1 \times C_2\right)\: \vec{sk} = C_1\left(\mu_2\:\vec{sk}\right) = (\mu_1 \mu_2)\:\vec{s}\]
\item \textbf{NAND:} $C_1 * C_2 - \text{Id}$
\item \textbf{Produit par scalaire:} $\lambda C_1\quad$
\end{itemize}
\end{frame} 

%% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{GSW, second essai:}
\textbf{Clé secrète:} un vecteur $sk \in \ZZq^{N}$ \\
\textbf{Clé publique:} pk\\
\textbf{Chiffrement:} Encrypt($\mu$) = $C\in \ZZq^{N \times N}\:$ telle que  
\[C \vec{sk} = \vec{sk} + {\color{red}\vec{e}}\qquad \text{avec }  {\color{red}\vec{e}} \text{ petit} \]
\textbf{Déchiffrement:} on prend un $i$ tel que $\vec{sk}_i$ est grand
\begin{align*}
\text{Decrypt}(sk, C) = \left\lfloor \frac{{\left(C\vec{sk}\right)}_i}{v_i} \right\rceil &= 
\left\lfloor \frac{{\left(\mu\vec{sk}_i + {\color{red}\vec{e}_i}\right)}_i}{v_i} \right\rceil \\
&= \left\lfloor \mu + \frac{\vec{e}_i}{v_i} \right\rceil \\
&= \mu
\end{align*}
\end{frame} 

%% ------------------------------------------------------------------------------------------------


\begin{frame} 
\frametitle{GSW, second essai:}
Retour sur les opérations homomorphes:
\begin{itemize}
\item \textbf{Somme:} $C_1 + C_2\quad$
\[\left(C_1 + C_2\right) \vec{sk} = (\mu_1 + \mu_2) \vec{sk} + {\color{red}\vec{e}_1 + \vec{e}_2}\]
\item \textbf{NAND:} $C_1 \times C_2 - \text{Id}$
\begin{align*}
\left(C_1 \times C_2 - \text{Id}\right) \vec{sk} &= C_1\left(\mu_2\vec{sk} + {\color{red}\vec{e}_2} - \vec{s}\right) \\
&= (\mu_1 \mu_2 - 1) \vec{sk} + {\color{red}\mu_2 \vec{e}_1 + C_1 \vec{e_2}}
\end{align*}
\end{itemize}

\textbf{Problème:} \\
Les coefficients de $C_1 \vec{e}_2$ peuvent être gros

\end{frame} 

%% ------------------------------------------------------------------------------------------------
  
\begin{frame} 
\frametitle{GSW, version finale:}
On utilise une fonction Flatten qui a notamment les propriétés suivantes:
\begin{align*}
&C \in \ZZq^{n \times n} \Rightarrow \text{Flatten}(C) \in \{0,1\}^{N \times N} \\
& \langle Flatten(C), \vec{sk} \rangle = \langle C, \vec{sk} \rangle \quad{ pour un secret \vec{sk} bien choisi}
\end{align*}

\textbf{Clé secrète:} un vecteur $s \in \ZZq^{N}$ bien choisi\\
\textbf{Clé publique:} pk\\
\textbf{Chiffrement:} Encrypt(pk, $\mu$) = $\text{Flatten}(C)\in \ZZq^{N \times N}\:$ pour $C$ telle que  
\[C \vec{sk} = \vec{sk} + {\color{red}\vec{e}}\qquad \text{avec }  {\color{red}\vec{e}} \text{ petit} \]
\textbf{Déchiffrement:} on prend un $i$ tel que $\vec{s}_i$ est grand et:
\[\text{Decrypt}(\vec{sk}, C) = \left\lfloor \frac{{\left(C\vec{s}\right)}_i}{v_i} \right\rceil \]

Opérations homomorphes: on applique Flatten aux précédentes opérations homomorphes.

\begin{itemize}
\item \textbf{Somme:} $\text{Flatten}\left(C_1 + C_2\right)\quad$ \\
\[\text{Flatten}\left(C_1 + C_2\right)\: \vec{sk} = (\mu_1 + \mu_2)\:\vec{sk} + {\color{red}\vec{e}_1 + \vec{e}_2}\]
Alors, la nouvelle erreur est majorée par $\bnorm{\vec{e_1}} + \bnorm{\vec{e_2}}$
\item \textbf{Produit:} $\text{Flatten}\left(C_1 \times C_2\right)\quad$ \\
\item \textbf{NAND} $\text{Flatten}\left(C_1 \times C_2 - \text{Id}\right)\quad$ \\
\[\text{Flatten}\left(C_1 \times C_2 - \text{Id}\right)\: \vec{sk} = (\mu_1 \mu_2 - 1)\: \vec{sk} + {\color{red}\mu_2 \vec{e}_1 + C_1 \vec{e_2}}\]
Comme $C_1 \in \{0,1\}^{N\times N}$, la nouvelle erreur est majorée par 
$\bnorm{\vec{e_1}} + N\:\bnorm{\vec{e_2}} \leqslant (1+N) \max\left(\bnorm{\vec{e}_1},\bnorm{\vec{e}_2}\right)$
\end{itemize}
\end{frame} 
  
%%------------------------------------------------------------------------------------------------
  
\begin{frame} 
\frametitle{Le problème DLWE}
\textbf{Paramètres:} $n, q\in \mathbb{N}$, une distribution $\chi$ sur $\ZZq$

Le problème DLWE($n,q,\chi$) consiste à distinguer deux distributions:
\begin{itemize}
\item La distribution qui crée uniformément $(\vec{a}, b) \in \ZZq^{n+1}$;
\item La distribution qui utilise un secret $\vec{s}\in \ZZq^n$ tiré uniformément, 
et crée des vecteurs $(\vec{a}, b)$ où
\[ b_i = \langle \vec{a}_i, \vec{s} \rangle + e_i \] 
$e_i$ étant échantillonné par $\chi$.
\end{itemize}
à partir d'un ensemble d'échantillons.
\end{frame} 

%%------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{FHE avec bootstrapping}
\[ C = D + \text{\textcolor{Orange}{erreur}} \]
  \noindent
  \begin{center}
      \begin{tikzpicture}[scale = 1, transform shape]
      	\input{../pictures/bootstrapping.tex}
      \end{tikzpicture}
  \end{center}
  \noindent
  \vspace{-0.7cm}

% \[ \text{Encrypt}\left(\text{sk},\: \text{Decrypt}\left(\text{sk},C\right)\right) \]

\pause
Soit $\Pi$ le circuit booléen tel que 
\[\quad\Pi(\text{binsk})= \text{Decrypt}\left(\text{sk}, C\right) \]

\pause
Alors:
\begin{align*}
\text{Encrypt}\left(\text{sk},\: \text{Decrypt}\left(\text{sk},C\right)\right) 
=& \text{Encrypt}\left(\text{sk},\: \Pi(\text{binsk})\right) \\
=& \text{Eval}\left(\Pi, \text{Encrypt}(\text{sk}, \text{binsk})\right)
\end{align*}
\vspace{-0.5cm}
\begin{itemize}
\item Si $\Pi$ contient assez peu de NAND, on peut avoir un FHE.
\end{itemize}

\end{frame} 

%% ------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Découpage de Decrypt}
L'algorithme de déchiffrement est le suivant:
\begin{enumerate}
\item trouver $1 \leqslant i \leqslant l$ tel que $q/4 \leqslant 2^i < q/2$
\item calculer $a = C_i \cdot \vec{v}$
\item retourner $|\frac{a}{\vec{v}_i}|$
\end{enumerate}

\begin{itemize}
\item On peut ramener le calcul du produit scalaire à une somme de nombres binaire;
\item Diviser par une puissance de $2$ est un shift à gauche sur l'écriture binaire;
\item Calculer la valeur valeur absolue implique essentiellement de faire un complément à 2.
\end{itemize}

Voyons comment sommer deux nombres binaires.

\end{frame} 

%% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{sommer deux listes: }
Somme classique entre deux nombres binaires:
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 1.2, transform shape]
      	\input{../pictures/classic_sum.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
\begin{itemize}
\item $a_1$ et $b_1$ présents dans la formule booléenne de $r_s$.
\item profondeur de NAND en $O(s)$
\end{itemize}
\end{frame} 
    
%% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{sommer deux listes: carry lookahead adder}
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.5, transform shape]
      	\input{../pictures/cla1.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}


\begin{columns}
\begin{column}{0.4\textwidth}
\pause
\begin{itemize}
\item $G$ pour génération
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.6, transform shape]
      	\input{../pictures/cla_sum_g.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
\item $P$ pour propagation
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.6, transform shape]
      	\input{../pictures/cla_sum_p.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
\end{itemize}
\end{column}

\begin{column}{0.6\textwidth}  %%<--- here
\pause

% \vspace{-1cm}

$(G1)_i = a_i \wedge b_i \quad (P1)_i = a_i \vee b_i$
\pause

  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.9, transform shape]
      	\input{../pictures/formula_recu.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}

${(G2^{i+1})}_1 = {(G2^i)}_2 \vee \left ( {(G2^i)}_1 \wedge {(P2^i)}_2 \right)$\\

\vspace{0.3cm}

${(P2^{i+1})}_1 = {(G2^i)}_1 \wedge {(P2^i)}_2$

\end{column}
\end{columns}

\end{frame} 

%%------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{sommer deux listes: carry lookahead added}
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.7, transform shape]
      	\input{../pictures/cla2.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
Les variables de générations de blocs commençants par 0 calculent des retenues.
\[\quad \]
\[\quad \]
\end{frame} 

%% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{sommer deux listes: carry lookahead added}
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.7, transform shape]
      	\input{../pictures/cla3.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
Les variables de générations de blocs commençants par 0 calculent des retenues.
\[c_6 = G2_3 \vee \left( c_4 \wedge P2_3\right) = 1 \vee \left( 1 \wedge 1 \right) = 1 \]
\[\quad\]
\end{frame} 

% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{sommer deux listes: carry lookahead added}
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.7, transform shape]
      	\input{../pictures/cla4.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
Les variables de générations de blocs commençants par 0 calculent des retenues.
\[c_6 = G2_3 \vee \left( c_4 \wedge P2_3\right) = 1 \vee \left( 1 \wedge 1 \right) = 1 \]
\[c_7 = G1_7 \vee \left( c_6 \wedge P1_7\right) = 0 \vee \left( 1 \wedge 0 \right) = 0 \]
\end{frame} 

%------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{Effectuer un bootstrapping}

\textbf{Profondeur de NAND totale majorée par :}
\[88 \lceil \log_2(\log_2(q)) \rceil + 36 \lceil \log_2(n) \rceil\]
avec n un paramètre du système.

Certains choix de paramètres permettent d'effectuer un bootstrapping en garantissant que le cryptosystème est IND-CPA.
\pause

\begin{figure}
\begin{tabular}{|c|c|c|c|}
\hline
sécurité & taille du secret & taille de la clé & taille d'un chiffré \\
\hline
$\lambda = 8$ & 3 Ko & 113 Mo & 135 Go \\
\hline
$\lambda = 16$ & 12 Ko & 2 Go & 6 To \\
\hline
$\lambda = 32$ & 45 Ko & 32 Go & 176 To \\
\hline
\end{tabular}
\end{figure}
\end{frame}

% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{The Gate Bootstrapping API}
\begin{itemize}
\item s'appuyant notamment sur des travaux de I. Chillotti, N. Gama, M. Georgieve et M. Izabachène 
\item librairie open source utilisable en C et C++ 
\item version modifiée du cryptosysteme GSW, avec une variante de LWE nommée TFHE.
\end{itemize}
Performances:
pour un ordinateur 64-bit simple coeur (i7-4930MX) cadencé à 3.00GHz, le bootstrapping se fait en un temps moyen de 52ms
et la clé de bootstrapping fait environ 24 Mo.
 

\end{frame} 

\begin{frame} 
On a considéré le scénario suivant:
\begin{itemize}
\item Alice génère des clés, chiffre deux nombres de 16 bits  et les inscrits dans un fichier;
\item Le cloud récupère les donnés, applique homomorphiquement la fonction minimum aux deux nombres et inscrit le résultat dans un fichier;
\item Alice récupère et déchiffre le résultat.
\end{itemize}
Pour un paramètre de sécurité $\lambda = 110$ et sur un ordinateur 64-bit quadri-coeur (i5-7200U CPU) cadendcé à 2.50GHz
on obtient un temps de 2.10s.
De plus, les taille des données sont les suivantes:

\begin{figure}
\begin{tabular}{|c|c|}
\hline
Données & Taille \\
\hline
Clé secrète & 79Mo \\
\hline
Clé publique et clé de bootstrapping  & 79Mo \\
\hline
Chiffrement d'un bit & 2Ko \\
\hline
Chiffrement des deux nombres & 64Ko\\
\hline
\end{tabular}
\end{figure}

\end{frame} 

% ------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Ce dont nous n'avons pas parlé}
\begin{itemize}
\item Flatten, dont nous avons caché la définition sous le tapis;
\item Deux autres algorithmes de déchiffrement;
\item Les gaussiennes discrètes;
\item Choix des paramètres pour un leveled FHE;
\item Contraintes de sécurité supplémentaires liées au bootstrapping;
\end{itemize}
\end{frame}

% ------------------------------------------------------------------------------------------------
\end{document}
