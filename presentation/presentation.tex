\documentclass[10pt,xcolor={usenames,dvipsnames}]{beamer}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% \usepackage{FiraSans}

\usetheme{metropolis}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor} % to have more colors.

% \usepackage{parallel}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{xcolor} % to put colors in equations, ex:  \color{red} ...  or
% \textcolor{red}{foo}: \
\usepackage{wrapfig}
\usepackage{enumerate}

\title{\'Etude d'un FHE de troisième génération}
\date{\today}
\author{Lucas Roux \& Eric Sageloli}

% used defined commands
\newcommand{\LWE}{\text{LWE}_{n,q,\chi}}
\newcommand{\DLWE}{\text{DLWE}_{n,q,\chi}}
\newcommand{\SD}{\text{SD}}
\newcommand{\id}{\text{I}}
\newcommand{\flatten}{\text{Flatten}}
\newcommand{\bitdecomp}{\text{BitDecomp}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZq}{\mathbb{Z}_q}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\norm}[1]{{\|#1\|}_{\infty}}
\newcommand{\bnorm}[1]{{|#1|}_{\text{bin}}}

\newcommand{\pk}{\text{pk}}
\newcommand{\sk}{\text{sk}}
\newcommand{\bsk}{\text{bsk}}
\newcommand{\evk}{\text{evk}}
\newcommand{\Dec}{\text{\textbf{Decrypt}}}
\newcommand{\Eval}{\text{\textbf{Eval}}}
\newcommand{\Keygen}{\text{\textbf{Keygen}}}
\newcommand{\Enc}{\text{\textbf{Encrypt}}}

\begin{document}
 \begin{frame} 
 \maketitle
 \end{frame}

%%------------------------------------------------------------------------------------------------

\begin{section}{Introduction}

 \begin{frame} 
 \frametitle{Un bref historique}
\textbf{Définition informelle: } un FHE (Fully homomorphic encryption) est un cryptosystème dont les chiffrés 
 sont sur définis sur un anneau $R$ et ayant des opérations sur les chiffrés qui 
 \og commutent \fg~avec les opérations 
 d'addition, de multiplication et de multiplication par un scalaire. 
\textbf{Définition alternative:} l'ensemble des messages est $\{0,1\}$ et le cryptosystème commute  
avec l'opération \text{NAND}.
\begin{itemize}
\item 2009: un premier plan par Craig Gentry dans sa thèse :
\begin{itemize}
\item idée du bootstrapping;
\end{itemize}
\item 2011: premiers FHE de seconde génération: Z.Brakerski, V.Vaikuntanathan, J.Fan, F.Vercauteren :
	\begin{itemize}
	\item basés sur LWE et ses variantes (comme RLWE);
	\item une somme simple à définir;
	\item un produit en 2 étapes;
	\end{itemize}
\item 2013: premiers FHE de troisième génération: GWS par C.Gentry, B.Waters and A.Sahai, en 2013 :
	\begin{itemize}
	\item basés sur LWE et ses variantes;
	\item produit et somme de même nature;
	\end{itemize}
\end{itemize}
\end{frame} 

\end{section}

%%------------------------------------------------------------------------------------------------

\begin{section}{Définition de GSW}

\begin{frame} 
\frametitle{GSW, premier essai:}
\textbf{Clé secrète:} un vecteur $\vec{sk} \in \ZZq^{n}$ \\
\textbf{Clé publique:} pk\\
\textbf{Chiffrement:} Encrypt(pk, $\mu$) = $C\in \ZZq^{n \times n}\:$ telle que  
\[C \vec{sk} = \mu\vec{sk}\]
\vspace{-1cm}

\textbf{Déchiffrement:} évident : recherche de valeur propre \\
\textbf{Opérations homomorphes:}\\
Pour {\small$C_i = \text{Encrypt}(\mu_i) \quad(1 \leqslant i \leqslant 2)$}
et $\lambda \in \ZZq$,
\begin{itemize}
\item \textbf{Somme:} $C_1 + C_2\quad$
\[\left(C_1 + C_2\right) \vec{sk} = (\mu_1 + \mu_2)\: \vec{sk}\]
\item \textbf{Produit:} $C_1 \times C_2\quad$
\[\left(C_1 \times C_2\right)\: \vec{sk} = C_1\left(\mu_2\:\vec{sk}\right) = (\mu_1 \mu_2)\:\vec{sk}\]
\item \textbf{NAND:} $C_1 \times C_2 - \text{Id}$
\item \textbf{Produit par scalaire:} $\lambda C_1\quad$
\end{itemize}
\end{frame} 

%% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{GSW, seconde tentative}
\textbf{Clé secrète:} un vecteur $\vec{sk} \in \ZZq^{n}$ \\
\textbf{Clé publique:} pk\\
\textbf{Chiffrement:} Encrypt($\mu$) = $C\in \ZZq^{n \times n}\:$ telle que  
\[C \vec{sk} = \vec{sk} + {\color{red}\vec{e}}\qquad \text{avec }  {\color{red}\vec{e}} \text{ petit} \]
\textbf{Déchiffrement:} on prend un $i$ tel que $\vec{sk}_i$ est grand
\begin{align*}
\text{Decrypt}(\vec{sk}, C) = \left\lfloor \frac{{\left(C\vec{sk}\right)}_i}{\vec{sk}_i} \right\rceil &= 
\left\lfloor \frac{{\left(\mu\vec{sk}_i + {\color{red}\vec{e}_i}\right)}_i}{\vec{sk}_i} \right\rceil \\
&= \left\lfloor \mu + \frac{\vec{e}_i}{\vec{sk}_i} \right\rceil \\
&= \mu
\end{align*}
\end{frame} 

%% ------------------------------------------------------------------------------------------------


\begin{frame} 
\frametitle{GSW, seconde tentative}
Retour sur les opérations homomorphes:
\begin{itemize}
\item \textbf{Somme:} $C_1 + C_2\quad$
\[\left(C_1 + C_2\right) \vec{sk} = (\mu_1 + \mu_2) \vec{sk} + {\color{red}\vec{e}_1 + \vec{e}_2}\]
\item \textbf{NAND:} $C_1 \times C_2 - \text{Id}$
\begin{align*}
\left(C_1 \times C_2 - \text{Id}\right) \vec{sk} &= C_1\left(\mu_2\vec{sk} + {\color{red}\vec{e}_2} - \vec{sk}\right) \\
&= (\mu_1 \mu_2 - 1) \vec{sk} + {\color{red}\mu_2 \vec{e}_1 + C_1 \vec{e_2}}
\end{align*}
\end{itemize}

\textbf{Problème:} \\
Les coefficients de $C_1 \vec{e}_2$ peuvent être gros.

\end{frame} 

%% ------------------------------------------------------------------------------------------------
  
\begin{frame} 
\frametitle{GSW, troisième tentative}
On utilise une fonction Flatten qui a notamment les propriétés suivantes:
\begin{align*}
&C \in \ZZq^{n \times n} \Rightarrow \text{Flatten}(C) \in \{0,1\}^{n \times n} \\
& \langle Flatten(C), \vec{sk} \rangle = \langle C, \vec{sk} \rangle \quad\text{pour un secret }\vec{sk}\text{ bien choisi}
\end{align*}

\textbf{Clé secrète:} un vecteur $\vec{sk} \in \ZZq^{n}$ bien choisi\\
\textbf{Clé publique:} pk\\
\textbf{Chiffrement:} Encrypt(pk, $\mu$) = $\text{Flatten}(C)\in \ZZq^{n \times n}\:$ pour $C$ telle que  
\[C \vec{sk} = \vec{sk} + {\color{red}\vec{e}}\qquad \text{avec }  {\color{red}\vec{e}} \text{ petit} \]
\textbf{Déchiffrement:} on prend un $i$ tel que $\vec{sk}_i$ est grand et:
\[\text{Decrypt}(\vec{sk}, C) = \left\lfloor \frac{{\left(C\vec{sk}\right)}_i}{\vec{sk}_i} \right\rceil \]

Opérations homomorphes: on applique Flatten aux précédentes opérations homomorphes.

\end{frame} 
  
%%------------------------------------------------------------------------------------------------
  
%%------------------------------------------------------------------------------------------------
\begin{frame} 
\frametitle{Le problème Decisional Learning With Error (DLWE)}
\textbf{paramètres:} le paramètre de sécurité $\color{blue}\lambda$,
la dimension ${\color{blue}n = n(\lambda)} \in \mathbb{N}$,
le module ${\color{blue}q = q(\lambda)} \in \mathbb{N}$,
une distribution ${\color{blue}\chi = \chi(\lambda)}$ à valeur dans $\mathbb{N}$,
un paramètre de nombre d'échantillons ${\color{blue}m = m(\lambda)}\in \mathbb{N}$.

\textbf{problème DLWE($n, q, \chi, m$):} 
distinguer si $A \in \ZZq^{m \times n+1}$ 
\begin{itemize}
\item a été échantillonnée uniformément; 
\item $A = (\vec{b}^\intercal ||B)$ où $B\in {\ZZq}^{m \times n}$
est échantillonnée uniformément et 
\[\vec{b} = {\color{red}\vec{e}} + B \vec{t}\]
pour  $\color{red}\vec{e}$ échantillonné par $\chi$ et $\vec{t}$ uniformément.
\end{itemize}

En notant $\vec{sk} = (1\: -\vec{t})$, on a
\[ A \:\vec{sk} = {\color{red}\vec{e}} \]


\textbf{Hypothèse DLWE:} Il existe une famille de paramètres telles qu'aucun algorithme polynomial
$\mathcal{A}$ n'a un avantage non négligeable pour distinguer les deux cas.
\end{frame} 


%%------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{clé publique et sécurité IND-CPA}
\textbf{Idée} prendre $\text{pk}= A$, et $\chi$ qui échantillonne de petites valeurs.

Pour chiffrer $\mu \in \ZZq$:
\[ C :=\mu\:\text{Id} + RA \qquad R\in {\{0,1\}}^{m \times n}\: \text{ tirée uniformément.} \]
Ainsi: $\quad C\:\vec{sk} = C \mu +  R {\color{red}\vec{e}}\:= C \mu + {\color{red}\vec{e'}}
\quad\:\: \text{avec } {\color{red}\vec{e'}} \text{ petit}$


\textbf{Sécurité:} pour des paramètres t.q l'hypothèse DLWE est vérifié:\\
\begin{itemize}
\item $A$ est indistinguable d'une matrice choisie uniformément. 
\item On montre que
$\nexists\:\: \mathcal{A}$ algorithme polynomial probabiliste distinguant
	\begin{itemize}
	\item $(A,AR)$ 
	\item un couple de matrices choisies uniformément.
	\end{itemize}
\end{itemize}

$C$ peut donc se voir comme un one-time pad.
\end{frame} 

%%------------------------------------------------------------------------------------------------

\end{section}

\begin{section}{Mise en place d'un bootstrapping}

\begin{frame} 
\frametitle{Evaluation d'un circuit booléen, profondeur de NAND}
Soit $a,b,c\in\{0, 1\}$ et $C_a, C_b, C_c$ leurs chiffrés pour des clés ($\vec{sk}$, pk)
  \begin{center}
      \begin{tikzpicture}[scale = 1, transform shape]
      	\input{../pictures/circuit.tex}
      \end{tikzpicture}
  \end{center}
  Si le circuit $\Pi$ a une profondeur de NAND assez faible:
  \[ \Pi(a,c,b) = \text{Decrypt}(\vec{sk}, \text{Eval}\left(\Pi, C_a, C_b, C_b)\right) \]
  On note alors:
  \[ \text{Encrypt}\left(\text{pk}, \Pi(a,c,b)\right) \approx \text{Eval}\left(\Pi, C_a, C_b, C_b\right) \]
\end{frame}

%%------------------------------------------------------------------------------------------------
 
\begin{frame} 
\frametitle{FHE avec bootstrapping}
\[ C = D + \text{\textcolor{Orange}{erreur}} \]
  \noindent
  \begin{center}
      \begin{tikzpicture}[scale = 1, transform shape]
      	\input{../pictures/bootstrapping.tex}
      \end{tikzpicture}
  \end{center}
  \noindent
  \vspace{-0.7cm}

\pause

Soit $\Pi$ le circuit booléen tel que 
\[\quad\Pi(\overrightarrow{binsk})= \text{Decrypt}\left(\vec{sk}, C\right) \]

\pause
Alors:
\begin{align*}
\text{Encrypt}\left(\vec{sk},\: \text{Decrypt}\left(\vec{sk},C\right)\right) 
=&\: \text{Encrypt}\left(\vec{sk},\: \Pi(\overrightarrow{binsk})\right) \\
\approx&\: \text{Eval}\left(\Pi, \text{Encrypt}(\vec{sk}, \overrightarrow{binsk})\right)
\end{align*}
\vspace{-0.5cm}
\begin{itemize}
\item Si $\Pi$ contient assez peu de NAND, on peut avoir un FHE.
\end{itemize}

\end{frame} 

%% ------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Découpage de Decrypt}
L'algorithme de déchiffrement est le suivant :
\begin{enumerate}
\item trouver $i$ tel que $\vec{sk}_i$ est grand et une puissance de 2; 
\item calculer $a = C_i \cdot \vec{sk}$
\item retourner $|\frac{a}{\vec{sk}_i}|$
\end{enumerate}

\begin{itemize}
\item On peut ramener le calcul du produit scalaire à une somme de nombres binaire;
\item La division est simplement un shift sur l'écriture binaire;
\item Calculer la valeur absolue implique essentiellement de faire un complément à 2.
\end{itemize}

Voyons comment sommer deux nombres binaires.

\end{frame} 

%% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{Sommer deux listes: }
Somme classique entre deux nombres binaires:
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 1.2, transform shape]
      	\input{../pictures/classic_sum.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
\begin{itemize}
\item $a_1$ et $b_1$ présents dans la formule booléenne de $r_s$.
\item profondeur de NAND en $O(s)$
\end{itemize}
\end{frame} 
    
%% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{Sommer deux listes: carry lookahead adder}
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.5, transform shape]
      	\input{../pictures/cla1.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}


\begin{columns}
\begin{column}{0.4\textwidth}
\pause
\begin{itemize}
\item $G$ pour génération
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.6, transform shape]
      	\input{../pictures/cla_sum_g.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
\item $P$ pour propagation
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.6, transform shape]
      	\input{../pictures/cla_sum_p.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
\end{itemize}
\end{column}

\begin{column}{0.6\textwidth}  %%<--- here
\pause

% \vspace{-1cm}

$(G1)_i = a_i \wedge b_i \quad (P1)_i = a_i \vee b_i$
\pause

  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.9, transform shape]
      	\input{../pictures/formula_recu.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}

${(G2^{i+1})}_1 = {(G2^i)}_2 \vee \left ( {(G2^i)}_1 \wedge {(P2^i)}_2 \right)$\\

\vspace{0.3cm}

${(P2^{i+1})}_1 = {(G2^i)}_1 \wedge {(P2^i)}_2$

\end{column}
\end{columns}

\end{frame} 

%%------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{Sommer deux listes: carry lookahead added}
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.7, transform shape]
      	\input{../pictures/cla2.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
Les variables de générations de blocs commençants par 0 calculent des retenues.
\[\quad \]
\[\quad \]
\end{frame} 

%% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{Sommer deux listes: carry lookahead added}
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.7, transform shape]
      	\input{../pictures/cla3.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
Les variables de générations de blocs commençants par 0 calculent des retenues.
\[c_6 = G2_3 \vee \left( c_4 \wedge P2_3\right) = 1 \vee \left( 1 \wedge 1 \right) = 1 \]
\[\quad\]
\end{frame} 

% ------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{sommer deux listes: carry lookahead added}
  \begin{figure}
    \begin{center}
      \begin{tikzpicture}[scale = 0.7, transform shape]
      	\input{../pictures/cla4.tex}
      \end{tikzpicture}
    \end{center}
  \end{figure}
Les variables de générations de blocs commençants par 0 calculent des retenues.
\[c_6 = G2_3 \vee \left( c_4 \wedge P2_3\right) = 1 \vee \left( 1 \wedge 1 \right) = 1 \]
\[c_7 = G1_7 \vee \left( c_6 \wedge P1_7\right) = 0 \vee \left( 1 \wedge 0 \right) = 0 \]
\end{frame} 

%------------------------------------------------------------------------------------------------

\begin{frame} 
\frametitle{Effectuer un bootstrapping}

%\textbf{Profondeur de NAND totale majorée par :}
%\[88 \lceil \log_2(\log_2(q)) \rceil + 36 \lceil \log_2(n) \rceil\]
\textbf{Profondeur de NAND totale en :} 
$$\mathcal{O}(\log(\log(q)) + \log(n))$$
avec n un paramètre du système.

Certains choix de paramètres permettent d'effectuer un bootstrapping en garantissant que le cryptosystème est IND-CPA.
\pause

\begin{figure}
\begin{tabular}{|c|c|c|c|}
\hline
sécurité & taille du secret & taille de la clé & taille d'un chiffré \\
\hline
$\lambda = 8$ & 3 Ko & 113 Mo & 135 Go \\
\hline
$\lambda = 16$ & 12 Ko & 2 Go & 6 To \\
\hline
$\lambda = 32$ & 45 Ko & 32 Go & 176 To \\
\hline
\end{tabular}
\end{figure}
\end{frame}

\end{section}
% ------------------------------------------------------------------------------------------------

\begin{section}{Un oeil sur le monde réel}


\begin{frame} 
\frametitle{The Gate Bootstrapping API}
\begin{itemize}
\item librairie open source utilisable en C et C++ 
\item utilise une version modifiée du cryptosysteme GSW, avec une variante de LWE nommée TFHE.
\item s'appuie notamment sur des travaux de I. Chillotti, N. Gama, M. Georgieve et M. Izabachène 
\end{itemize}
\textbf{Performances} : pour un ordinateur 64-bit simple coeur (i7-4930MX) cadencé à 3.00GHz, le bootstrapping se fait en un temps moyen de 52ms
et la clé de bootstrapping fait environ 24 Mo.
 

\end{frame} 

\begin{frame} 
\frametitle{The Gate Bootstrapping API}
\begin{itemize}
\item Alice génère des clés, chiffre deux nombres de 16 bits et les inscrits dans un fichier;
\item le cloud récupère les données, applique homomorphiquement la fonction minimum aux deux nombres et inscrit le résultat dans un fichier;
\item Alice récupère et déchiffre le résultat.
\end{itemize}
\textbf{Performances} : pour un paramètre de sécurité $\lambda = 110$ et sur un ordinateur 64-bit quadri-coeur (i5-7200U CPU) cadencé à 2.50GHz, on obtient un temps de 2.10s.

On a alors des données de tailles :

\begin{figure}
\begin{tabular}{|c|c|}
\hline
Données & Taille \\
\hline
Clé secrète & 79 Mo \\
\hline
Clé publique et clé de bootstrapping  & 79 Mo \\
\hline
Chiffrement d'un bit & 2 Ko \\
\hline
Chiffrement des deux nombres & 64 Ko\\
\hline
\end{tabular}
\end{figure}

\end{frame} 

% ------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Ce dont nous n'avons pas parlé}
Concernant la définition de GSW:
\begin{itemize}
\item flatten, dont nous avons caché la définition sous le tapis;
\item deux autres algorithmes de déchiffrement.
\end{itemize}
Concernant les choix paramètres et la sécurité:

\begin{itemize}
\item hypothèses de sécurité sur DLWE, définitions équivalentes, lien LWE/DLWE;
\item les gaussiennes discrètes;
\item la librairie sagemath lwe\_estimator pour estimer la sécurité de paramètres LWE;
\item La notion de leveled FHE et des choix des paramètres pour un leveled FHE.
\end{itemize}

Concernant le bootstrapping:
\begin{itemize}
\item des optimisations supplémentaires pour sommer plusieurs nombres binaires;
\item contraintes de sécurité supplémentaires (sécurité circulaire).
\end{itemize}
\end{frame}

\end{section}


% ------------------------------------------------------------------------------------------------
\end{document}
